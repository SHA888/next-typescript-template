{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js 14+ Project with TypeScript",
        "description": "Set up a new Next.js 14+ project with TypeScript, replacing the existing Vite and React Router setup.",
        "details": "1. Create a new Next.js project with App Router:\n```bash\nnpx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir\n```\n2. Configure essential dependencies in package.json:\n```json\n{\n  \"dependencies\": {\n    \"next\": \"^14.0.0\",\n    \"react\": \"^18.3.0\",\n    \"react-dom\": \"^18.3.0\",\n    \"@prisma/client\": \"^5.0.0\",\n    \"zod\": \"^3.22.0\",\n    \"@tanstack/react-query\": \"^5.0.0\",\n    \"next-themes\": \"^0.2.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.5.0\",\n    \"@types/node\": \"^20.0.0\",\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-dom\": \"^18.2.0\",\n    \"prisma\": \"^5.0.0\",\n    \"eslint\": \"^8.0.0\",\n    \"eslint-config-next\": \"^14.0.0\",\n    \"prettier\": \"^3.0.0\"\n  }\n}\n```\n3. Set up Next.js configuration in next.config.js:\n```javascript\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n  experimental: {\n    serverActions: true,\n  },\n};\n\nmodule.exports = nextConfig;\n```\n4. Create basic folder structure according to App Router conventions:\n```\n/app\n  /page.tsx\n  /layout.tsx\n  /api\n/components\n/lib\n/public\n```",
        "testStrategy": "1. Verify the project builds without errors: `npm run build`\n2. Ensure the development server starts correctly: `npm run dev`\n3. Confirm TypeScript is properly configured by checking for type errors: `npx tsc --noEmit`\n4. Validate that the App Router structure works by navigating to the home page in the browser\n5. Test that the Next.js configuration is applied correctly by checking build output",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Configure Code Quality Tools and Git Hooks",
        "description": "Set up ESLint, Prettier, Husky, and lint-staged for code quality enforcement and pre-commit hooks.",
        "details": "1. Install additional dev dependencies:\n```bash\nnpm install --save-dev husky lint-staged @typescript-eslint/eslint-plugin @typescript-eslint/parser prettier-plugin-tailwindcss\n```\n\n2. Configure ESLint in `.eslintrc.js`:\n```javascript\nmodule.exports = {\n  extends: ['next/core-web-vitals', 'plugin:@typescript-eslint/recommended'],\n  parser: '@typescript-eslint/parser',\n  plugins: ['@typescript-eslint'],\n  rules: {\n    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],\n    'no-console': ['warn', { allow: ['warn', 'error'] }],\n  },\n};\n```\n\n3. Configure Prettier in `.prettierrc`:\n```json\n{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\",\n  \"printWidth\": 100,\n  \"plugins\": [\"prettier-plugin-tailwindcss\"]\n}\n```\n\n4. Set up Husky and lint-staged:\n```bash\nnpx husky-init && npm install\nnpx husky add .husky/pre-commit \"npx lint-staged\"\n```\n\n5. Configure lint-staged in `package.json`:\n```json\n{\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": [\n      \"eslint --fix\",\n      \"prettier --write\"\n    ],\n    \"*.{json,css,md}\": [\n      \"prettier --write\"\n    ]\n  }\n}\n```\n\n6. Add scripts to `package.json`:\n```json\n{\n  \"scripts\": {\n    \"lint\": \"next lint\",\n    \"lint:fix\": \"next lint --fix\",\n    \"format\": \"prettier --write .\",\n    \"type-check\": \"tsc --noEmit\"\n  }\n}\n```",
        "testStrategy": "1. Run ESLint to verify configuration: `npm run lint`\n2. Test Prettier formatting: `npm run format`\n3. Verify TypeScript type checking: `npm run type-check`\n4. Test Husky pre-commit hooks by making a commit with linting errors\n5. Ensure lint-staged correctly processes staged files before commit",
        "priority": "high",
        "dependencies": [1],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Set Up Tailwind CSS and shadcn/ui Component Library",
        "description": "Configure Tailwind CSS with proper theming and integrate the shadcn/ui component library for consistent UI components.",
        "details": "1. Ensure Tailwind CSS is properly configured (should be done during Next.js setup):\n```bash\nnpm install -D tailwindcss postcss autoprefixer tailwindcss-animate\n```\n\n2. Configure Tailwind CSS in `tailwind.config.js`:\n```javascript\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  darkMode: [\"class\"],\n  content: [\n    './pages/**/*.{ts,tsx}',\n    './components/**/*.{ts,tsx}',\n    './app/**/*.{ts,tsx}',\n    './src/**/*.{ts,tsx}',\n  ],\n  theme: {\n    container: {\n      center: true,\n      padding: \"2rem\",\n      screens: {\n        \"2xl\": \"1400px\",\n      },\n    },\n    extend: {\n      colors: {\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n      },\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: { height: \"0\" },\n          to: { height: \"var(--radix-accordion-content-height)\" },\n        },\n        \"accordion-up\": {\n          from: { height: \"var(--radix-accordion-content-height)\" },\n          to: { height: \"0\" },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\")],\n};\n```\n\n3. Create CSS variables in `app/globals.css`:\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 222.2 84% 4.9%;\n    --card: 0 0% 100%;\n    --card-foreground: 222.2 84% 4.9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 222.2 84% 4.9%;\n    --primary: 221.2 83.2% 53.3%;\n    --primary-foreground: 210 40% 98%;\n    --secondary: 210 40% 96.1%;\n    --secondary-foreground: 222.2 47.4% 11.2%;\n    --muted: 210 40% 96.1%;\n    --muted-foreground: 215.4 16.3% 46.9%;\n    --accent: 210 40% 96.1%;\n    --accent-foreground: 222.2 47.4% 11.2%;\n    --destructive: 0 84.2% 60.2%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 214.3 31.8% 91.4%;\n    --input: 214.3 31.8% 91.4%;\n    --ring: 221.2 83.2% 53.3%;\n    --radius: 0.5rem;\n  }\n\n  .dark {\n    --background: 222.2 84% 4.9%;\n    --foreground: 210 40% 98%;\n    --card: 222.2 84% 4.9%;\n    --card-foreground: 210 40% 98%;\n    --popover: 222.2 84% 4.9%;\n    --popover-foreground: 210 40% 98%;\n    --primary: 217.2 91.2% 59.8%;\n    --primary-foreground: 222.2 47.4% 11.2%;\n    --secondary: 217.2 32.6% 17.5%;\n    --secondary-foreground: 210 40% 98%;\n    --muted: 217.2 32.6% 17.5%;\n    --muted-foreground: 215 20.2% 65.1%;\n    --accent: 217.2 32.6% 17.5%;\n    --accent-foreground: 210 40% 98%;\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 217.2 32.6% 17.5%;\n    --input: 217.2 32.6% 17.5%;\n    --ring: 224.3 76.3% 48%;\n  }\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n  body {\n    @apply bg-background text-foreground;\n  }\n}\n```\n\n4. Set up shadcn/ui components:\n```bash\nnpx shadcn-ui@latest init\n```\n\n5. Create a utils.ts file in the lib directory for the cn utility:\n```typescript\n// lib/utils.ts\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n6. Install and set up theme provider:\n```bash\nnpm install next-themes\nnpx shadcn-ui@latest add button\n```\n\n7. Create a theme provider component:\n```typescript\n// components/theme-provider.tsx\n\"use client\";\n\nimport * as React from \"react\";\nimport { ThemeProvider as NextThemesProvider } from \"next-themes\";\nimport { type ThemeProviderProps } from \"next-themes/dist/types\";\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;\n}\n```\n\n8. Add theme provider to root layout:\n```typescript\n// app/layout.tsx\nimport { ThemeProvider } from \"@/components/theme-provider\";\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body>\n        <ThemeProvider attribute=\"class\" defaultTheme=\"system\" enableSystem>\n          {children}\n        </ThemeProvider>\n      </body>\n    </html>\n  );\n}\n```",
        "testStrategy": "1. Verify Tailwind CSS is working by applying utility classes to elements\n2. Test dark mode functionality with the theme provider\n3. Install and test several shadcn/ui components to ensure they render correctly\n4. Verify responsive design works across different viewport sizes\n5. Test that the theme persists across page refreshes\n6. Validate that custom CSS variables are applied correctly to components",
        "priority": "high",
        "dependencies": [1],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Prisma ORM Integration",
        "description": "Set up Prisma ORM with the initial database schema, migrations, and client configuration for type-safe database operations. Include all models required by the application as specified in the PRD.",
        "status": "done",
        "dependencies": [1],
        "priority": "high",
        "details": "1. Install Prisma:\n```bash\nnpm install @prisma/client\nnpm install -D prisma\n```\n\n2. Initialize Prisma:\n```bash\nnpx prisma init\n```\n\n3. Configure the database connection in `.env`:\n```\nDATABASE_URL=\"postgresql://username:password@localhost:5432/mydb?schema=public\"\n# Or for MongoDB:\n# DATABASE_URL=\"mongodb+srv://username:password@cluster.mongodb.net/mydb?retryWrites=true&w=majority\"\n```\n\n4. Create the comprehensive schema in `prisma/schema.prisma` with all required models:\n```prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\" // or \"mongodb\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id            String    @id @default(cuid())\n  name          String?\n  email         String?   @unique\n  emailVerified DateTime?\n  image         String?\n  password      String?\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n  accounts      Account[]\n  sessions      Session[]\n}\n\nmodel Account {\n  id                String  @id @default(cuid())\n  userId            String\n  type              String\n  provider          String\n  providerAccountId String\n  refresh_token     String? @db.Text\n  access_token      String? @db.Text\n  expires_at        Int?\n  token_type        String?\n  scope             String?\n  id_token          String? @db.Text\n  session_state     String?\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n  @@index([userId])\n}\n\nmodel Session {\n  id           String   @id @default(cuid())\n  sessionToken String   @unique\n  userId       String\n  expires      DateTime\n  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId])\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String   @unique\n  expires    DateTime\n\n  @@unique([identifier, token])\n}\n```\n\n5. Create a Prisma client instance in `lib/prisma.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n```\n\n6. Create initial migration:\n```bash\nnpx prisma migrate dev --name init\n```\n\n7. Create a database seed script in `prisma/seed.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  // Create a test user\n  await prisma.user.upsert({\n    where: { email: 'test@example.com' },\n    update: {},\n    create: {\n      email: 'test@example.com',\n      name: 'Test User',\n    },\n  });\n\n  console.log('Database has been seeded.');\n}\n\nmain()\n  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n```\n\n8. Add seed script to `package.json`:\n```json\n{\n  \"prisma\": {\n    \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"\n  }\n}\n```\n\n9. Install ts-node for seeding:\n```bash\nnpm install -D ts-node\n```\n\n10. Ensure all relationships between models are properly defined with appropriate indexes and constraints as shown in the schema.",
        "testStrategy": "1. Verify Prisma schema compiles without errors: `npx prisma validate`\n2. Test database connection: `npx prisma db pull`\n3. Run migrations to ensure they apply correctly: `npx prisma migrate dev`\n4. Test seeding functionality: `npx prisma db seed`\n5. Create a simple script to query the database and verify type safety\n6. Verify that Prisma Client is properly instantiated in the application\n7. Test database operations in a development environment\n8. Verify all relationships between models work correctly\n9. Test foreign key constraints and cascading deletes\n10. Validate that indexes are properly created for performance optimization",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Core Layout and UI Components",
        "description": "Implement the core layout structure and essential UI components following the App Router architecture.",
        "details": "1. Create the root layout in `app/layout.tsx`:\n```typescript\nimport { ReactNode } from \"react\";\nimport { Inter } from \"next/font/google\";\nimport { ThemeProvider } from \"@/components/theme-provider\";\nimport { cn } from \"@/lib/utils\";\n\nimport \"@/styles/globals.css\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata = {\n  title: \"Next.js TypeScript Template\",\n  description: \"A modern full-stack web application template\",\n};\n\nexport default function RootLayout({ children }: { children: ReactNode }) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body className={cn(\n        \"min-h-screen bg-background font-sans antialiased\",\n        inter.className\n      )}>\n        <ThemeProvider\n          attribute=\"class\"\n          defaultTheme=\"system\"\n          enableSystem\n          disableTransitionOnChange\n        >\n          {children}\n        </ThemeProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n2. Create a header component in `components/layout/header.tsx`:\n```typescript\nimport Link from \"next/link\";\nimport { ThemeToggle } from \"@/components/theme-toggle\";\n\nexport function Header() {\n  return (\n    <header className=\"sticky top-0 z-40 w-full border-b bg-background\">\n      <div className=\"container flex h-16 items-center space-x-4 sm:justify-between sm:space-x-0\">\n        <div className=\"flex gap-6 md:gap-10\">\n          <Link href=\"/\" className=\"flex items-center space-x-2\">\n            <span className=\"inline-block font-bold\">Next.js Template</span>\n          </Link>\n          <nav className=\"flex gap-6\">\n            <Link\n              href=\"/\"\n              className=\"flex items-center text-sm font-medium text-muted-foreground\"\n            >\n              Home\n            </Link>\n            <Link\n              href=\"/examples\"\n              className=\"flex items-center text-sm font-medium text-muted-foreground\"\n            >\n              Examples\n            </Link>\n          </nav>\n        </div>\n        <div className=\"flex flex-1 items-center justify-end space-x-4\">\n          <ThemeToggle />\n        </div>\n      </div>\n    </header>\n  );\n}\n```\n\n3. Create a theme toggle component in `components/theme-toggle.tsx`:\n```typescript\n\"use client\";\n\nimport * as React from \"react\";\nimport { useTheme } from \"next-themes\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Icons } from \"@/components/icons\";\n\nexport function ThemeToggle() {\n  const { setTheme, theme } = useTheme();\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      onClick={() => setTheme(theme === \"light\" ? \"dark\" : \"light\")}\n    >\n      <Icons.sun className=\"h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0\" />\n      <Icons.moon className=\"absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100\" />\n      <span className=\"sr-only\">Toggle theme</span>\n    </Button>\n  );\n}\n```\n\n4. Create an icons component in `components/icons.tsx`:\n```typescript\nimport {\n  Moon,\n  Sun,\n  type LucideIcon,\n} from \"lucide-react\";\n\nexport type Icon = LucideIcon;\n\nexport const Icons = {\n  sun: Sun,\n  moon: Moon,\n};\n```\n\n5. Create a footer component in `components/layout/footer.tsx`:\n```typescript\nexport function Footer() {\n  return (\n    <footer className=\"border-t py-6 md:py-0\">\n      <div className=\"container flex flex-col items-center justify-between gap-4 md:h-24 md:flex-row\">\n        <p className=\"text-center text-sm leading-loose text-muted-foreground md:text-left\">\n          &copy; {new Date().getFullYear()} Next.js TypeScript Template. All rights reserved.\n        </p>\n      </div>\n    </footer>\n  );\n}\n```\n\n6. Create a main layout wrapper in `components/layout/main-layout.tsx`:\n```typescript\nimport { ReactNode } from \"react\";\nimport { Header } from \"@/components/layout/header\";\nimport { Footer } from \"@/components/layout/footer\";\n\nexport function MainLayout({ children }: { children: ReactNode }) {\n  return (\n    <div className=\"relative flex min-h-screen flex-col\">\n      <Header />\n      <main className=\"flex-1\">{children}</main>\n      <Footer />\n    </div>\n  );\n}\n```\n\n7. Update the home page in `app/page.tsx`:\n```typescript\nimport { MainLayout } from \"@/components/layout/main-layout\";\n\nexport default function HomePage() {\n  return (\n    <MainLayout>\n      <section className=\"container grid items-center gap-6 pb-8 pt-6 md:py-10\">\n        <div className=\"flex max-w-[980px] flex-col items-start gap-2\">\n          <h1 className=\"text-3xl font-extrabold leading-tight tracking-tighter md:text-4xl\">\n            Next.js TypeScript Template\n          </h1>\n          <p className=\"max-w-[700px] text-lg text-muted-foreground\">\n            A modern, full-stack web application template with Next.js, TypeScript, and Prisma.\n          </p>\n        </div>\n      </section>\n    </MainLayout>\n  );\n}\n```",
        "testStrategy": "1. Verify all components render correctly without errors\n2. Test responsive design across different viewport sizes\n3. Ensure theme toggle functionality works correctly\n4. Validate navigation links work properly\n5. Test layout components with different content sizes\n6. Verify proper nesting of layout components\n7. Check accessibility of all UI components using tools like Lighthouse",
        "priority": "medium",
        "dependencies": [1, 3],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Next.js API Routes with Prisma Integration",
        "description": "Create type-safe API routes using the App Router's route handlers with Prisma integration for database operations.",
        "details": "1. Create a users API route in `app/api/users/route.ts`:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\n\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const page = parseInt(searchParams.get('page') || '1');\n  const pageSize = parseInt(searchParams.get('pageSize') || '10');\n  \n  try {\n    const users = await prisma.user.findMany({\n      skip: (page - 1) * pageSize,\n      take: pageSize,\n      orderBy: { createdAt: 'desc' },\n    });\n    \n    const total = await prisma.user.count();\n    \n    return NextResponse.json({\n      data: users,\n      meta: {\n        total,\n        page,\n        pageSize,\n        totalPages: Math.ceil(total / pageSize),\n      },\n    });\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch users' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    \n    const user = await prisma.user.create({\n      data: body,\n    });\n    \n    return NextResponse.json(user, { status: 201 });\n  } catch (error) {\n    console.error('Error creating user:', error);\n    return NextResponse.json(\n      { error: 'Failed to create user' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n2. Create a single user API route in `app/api/users/[id]/route.ts`:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\n\nexport async function GET(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const user = await prisma.user.findUnique({\n      where: { id: params.id },\n    });\n    \n    if (!user) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      );\n    }\n    \n    return NextResponse.json(user);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch user' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function PUT(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const body = await request.json();\n    \n    const user = await prisma.user.update({\n      where: { id: params.id },\n      data: body,\n    });\n    \n    return NextResponse.json(user);\n  } catch (error) {\n    console.error('Error updating user:', error);\n    return NextResponse.json(\n      { error: 'Failed to update user' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function DELETE(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  try {\n    await prisma.user.delete({\n      where: { id: params.id },\n    });\n    \n    return new NextResponse(null, { status: 204 });\n  } catch (error) {\n    console.error('Error deleting user:', error);\n    return NextResponse.json(\n      { error: 'Failed to delete user' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n3. Create a middleware for API routes in `middleware.ts`:\n```typescript\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  // Add CORS headers for API routes\n  if (request.nextUrl.pathname.startsWith('/api')) {\n    const response = NextResponse.next();\n    response.headers.set('Access-Control-Allow-Origin', '*');\n    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    return response;\n  }\n  \n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/api/:path*'],\n};\n```\n\n4. Create API response types in `lib/types.ts`:\n```typescript\nexport interface ApiResponse<T> {\n  data: T;\n  meta?: {\n    total?: number;\n    page?: number;\n    pageSize?: number;\n    totalPages?: number;\n  };\n}\n\nexport interface ApiError {\n  error: string;\n}\n```\n\n5. Create a utility for API requests in `lib/api-utils.ts`:\n```typescript\nimport { ApiError, ApiResponse } from './types';\n\nexport async function fetchApi<T>(\n  url: string,\n  options?: RequestInit\n): Promise<ApiResponse<T>> {\n  const response = await fetch(url, {\n    ...options,\n    headers: {\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    },\n  });\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error((data as ApiError).error || 'An error occurred');\n  }\n\n  return data as ApiResponse<T>;\n}\n```",
        "testStrategy": "1. Test each API endpoint with valid requests to ensure proper responses\n2. Test error handling with invalid requests\n3. Verify pagination works correctly in list endpoints\n4. Test CRUD operations against a test database\n5. Verify middleware correctly applies CORS headers\n6. Test API utility functions with mock responses\n7. Validate type safety of API responses\n8. Test performance with larger datasets",
        "priority": "high",
        "dependencies": [1, 4],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Authentication with NextAuth.js",
        "description": "Set up authentication using JWT and Passport in NestJS backend with Next.js frontend integration, including login/signup flows and protected routes.",
        "status": "done",
        "dependencies": [4, 5, 6],
        "priority": "medium",
        "details": "1. Install authentication packages for NestJS backend:\n```bash\nnpm install --save @nestjs/passport passport passport-local passport-jwt @nestjs/jwt bcrypt\nnpm install --save-dev @types/passport-local @types/passport-jwt @types/bcrypt\n```\n\n2. Update the Prisma schema to support authentication in `prisma/schema.prisma`:\n```prisma\nmodel User {\n  id            String    @id @default(cuid())\n  name          String?\n  email         String    @unique\n  password      String\n  role          String    @default(\"user\")\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n}\n```\n\n3. Run a migration to update the database schema:\n```bash\nnpx prisma migrate dev --name auth\n```\n\n4. Create authentication module in NestJS:\n```typescript\n// src/auth/auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { AuthService } from './auth.service';\nimport { AuthController } from './auth.controller';\nimport { LocalStrategy } from './strategies/local.strategy';\nimport { JwtStrategy } from './strategies/jwt.strategy';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      useFactory: async (configService: ConfigService) => ({\n        secret: configService.get<string>('JWT_SECRET'),\n        signOptions: { expiresIn: '1d' },\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n  controllers: [AuthController],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n5. Implement authentication service:\n```typescript\n// src/auth/auth.service.ts\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { UsersService } from '../users/users.service';\nimport { compare, hash } from 'bcrypt';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private usersService: UsersService,\n    private jwtService: JwtService,\n  ) {}\n\n  async validateUser(email: string, password: string): Promise<any> {\n    const user = await this.usersService.findByEmail(email);\n    if (!user) {\n      return null;\n    }\n    \n    const isPasswordValid = await compare(password, user.password);\n    if (!isPasswordValid) {\n      return null;\n    }\n    \n    const { password: _, ...result } = user;\n    return result;\n  }\n\n  async login(user: any) {\n    const payload = { email: user.email, sub: user.id, role: user.role };\n    return {\n      access_token: this.jwtService.sign(payload),\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role,\n      },\n    };\n  }\n\n  async register(name: string, email: string, password: string) {\n    const existingUser = await this.usersService.findByEmail(email);\n    if (existingUser) {\n      throw new UnauthorizedException('Email already in use');\n    }\n    \n    const hashedPassword = await hash(password, 10);\n    const user = await this.usersService.create({\n      name,\n      email,\n      password: hashedPassword,\n    });\n    \n    const { password: _, ...result } = user;\n    return result;\n  }\n}\n```\n\n6. Create authentication strategies:\n```typescript\n// src/auth/strategies/local.strategy.ts\nimport { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from '../auth.service';\n\n@Injectable()\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(private authService: AuthService) {\n    super({ usernameField: 'email' });\n  }\n\n  async validate(email: string, password: string): Promise<any> {\n    const user = await this.authService.validateUser(email, password);\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n    return user;\n  }\n}\n\n// src/auth/strategies/jwt.strategy.ts\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(private configService: ConfigService) {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: configService.get<string>('JWT_SECRET'),\n    });\n  }\n\n  async validate(payload: any) {\n    return { id: payload.sub, email: payload.email, role: payload.role };\n  }\n}\n```\n\n7. Create authentication guards and decorators:\n```typescript\n// src/auth/guards/jwt-auth.guard.ts\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}\n\n// src/auth/guards/roles.guard.ts\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ROLES_KEY } from '../decorators/roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (!requiredRoles) {\n      return true;\n    }\n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some((role) => user.role === role);\n  }\n}\n\n// src/auth/decorators/roles.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);\n\n// src/auth/decorators/current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.user;\n  },\n);\n```\n\n8. Create authentication controller:\n```typescript\n// src/auth/auth.controller.ts\nimport { Controller, Post, Body, UseGuards, Get } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalAuthGuard } from './guards/local-auth.guard';\nimport { JwtAuthGuard } from './guards/jwt-auth.guard';\nimport { CurrentUser } from './decorators/current-user.decorator';\n\n@Controller('auth')\nexport class AuthController {\n  constructor(private authService: AuthService) {}\n\n  @Post('register')\n  async register(\n    @Body('name') name: string,\n    @Body('email') email: string,\n    @Body('password') password: string,\n  ) {\n    return this.authService.register(name, email, password);\n  }\n\n  @UseGuards(LocalAuthGuard)\n  @Post('login')\n  async login(@CurrentUser() user) {\n    return this.authService.login(user);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('profile')\n  getProfile(@CurrentUser() user) {\n    return user;\n  }\n}\n```\n\n9. Create a Next.js API service for authentication in `lib/api-service.ts`:\n```typescript\n// lib/api-service.ts\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';\n\nexport async function login(email: string, password: string) {\n  const response = await fetch(`${API_URL}/auth/login`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ email, password }),\n  });\n\n  if (!response.ok) {\n    throw new Error('Login failed');\n  }\n\n  return response.json();\n}\n\nexport async function register(name: string, email: string, password: string) {\n  const response = await fetch(`${API_URL}/auth/register`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ name, email, password }),\n  });\n\n  if (!response.ok) {\n    throw new Error('Registration failed');\n  }\n\n  return response.json();\n}\n\nexport async function getProfile(token: string) {\n  const response = await fetch(`${API_URL}/auth/profile`, {\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error('Failed to get profile');\n  }\n\n  return response.json();\n}\n```\n\n10. Create an authentication context in Next.js frontend in `contexts/auth-context.tsx`:\n```typescript\n// contexts/auth-context.tsx\n\"use client\";\n\nimport { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { login as apiLogin, register as apiRegister, getProfile } from '@/lib/api-service';\n\ntype User = {\n  id: string;\n  name: string;\n  email: string;\n  role: string;\n};\n\ntype AuthContextType = {\n  user: User | null;\n  token: string | null;\n  login: (email: string, password: string) => Promise<void>;\n  register: (name: string, email: string, password: string) => Promise<void>;\n  logout: () => void;\n  isLoading: boolean;\n};\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [token, setToken] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const router = useRouter();\n\n  useEffect(() => {\n    // Check for token in localStorage\n    const storedToken = localStorage.getItem('auth_token');\n    if (storedToken) {\n      setToken(storedToken);\n      getProfile(storedToken)\n        .then(userData => {\n          setUser(userData);\n        })\n        .catch(() => {\n          localStorage.removeItem('auth_token');\n          setToken(null);\n        })\n        .finally(() => {\n          setIsLoading(false);\n        });\n    } else {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const login = async (email: string, password: string) => {\n    setIsLoading(true);\n    try {\n      const response = await apiLogin(email, password);\n      setToken(response.access_token);\n      setUser(response.user);\n      localStorage.setItem('auth_token', response.access_token);\n      router.push('/');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const register = async (name: string, email: string, password: string) => {\n    setIsLoading(true);\n    try {\n      await apiRegister(name, email, password);\n      await login(email, password);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const logout = () => {\n    setUser(null);\n    setToken(null);\n    localStorage.removeItem('auth_token');\n    router.push('/auth/signin');\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, token, login, register, logout, isLoading }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n```\n\n11. Update the sign-in page in `app/auth/signin/page.tsx`:\n```typescript\n\"use client\";\n\nimport { useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { MainLayout } from \"@/components/layout/main-layout\";\nimport { useAuth } from \"@/contexts/auth-context\";\n\nexport default function SignInPage() {\n  const router = useRouter();\n  const { login } = useAuth();\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setIsLoading(true);\n    setError(\"\");\n\n    try {\n      await login(email, password);\n      router.push(\"/\");\n    } catch (error) {\n      setError(\"Invalid email or password\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <MainLayout>\n      <div className=\"container flex h-screen flex-col items-center justify-center\">\n        <div className=\"mx-auto flex w-full flex-col justify-center space-y-6 sm:w-[350px]\">\n          <div className=\"flex flex-col space-y-2 text-center\">\n            <h1 className=\"text-2xl font-semibold tracking-tight\">Sign In</h1>\n            <p className=\"text-sm text-muted-foreground\">\n              Enter your credentials to sign in to your account\n            </p>\n          </div>\n          <form onSubmit={handleSubmit} className=\"space-y-4\">\n            {error && (\n              <div className=\"rounded-md bg-destructive/15 p-3 text-sm text-destructive\">\n                {error}\n              </div>\n            )}\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"email\">Email</Label>\n              <Input\n                id=\"email\"\n                type=\"email\"\n                placeholder=\"name@example.com\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n              />\n            </div>\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"password\">Password</Label>\n              <Input\n                id=\"password\"\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                required\n              />\n            </div>\n            <Button type=\"submit\" className=\"w-full\" disabled={isLoading}>\n              {isLoading ? \"Signing in...\" : \"Sign In\"}\n            </Button>\n          </form>\n        </div>\n      </div>\n    </MainLayout>\n  );\n}\n```\n\n12. Add the auth provider to the root layout:\n```typescript\n// app/layout.tsx\nimport { AuthProvider } from \"@/contexts/auth-context\";\n\nexport default function RootLayout({ children }: { children: ReactNode }) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body className={cn(\n        \"min-h-screen bg-background font-sans antialiased\",\n        inter.className\n      )}>\n        <AuthProvider>\n          <ThemeProvider\n            attribute=\"class\"\n            defaultTheme=\"system\"\n            enableSystem\n            disableTransitionOnChange\n          >\n            {children}\n          </ThemeProvider>\n        </AuthProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n13. Create a protected route HOC in `components/protected-route.tsx`:\n```typescript\n\"use client\";\n\nimport { useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { useAuth } from '@/contexts/auth-context';\n\nexport function withAuth(Component: React.ComponentType, requiredRole?: string) {\n  return function ProtectedRoute(props: any) {\n    const { user, isLoading } = useAuth();\n    const router = useRouter();\n\n    useEffect(() => {\n      if (!isLoading && !user) {\n        router.push('/auth/signin');\n      }\n      \n      if (!isLoading && user && requiredRole && user.role !== requiredRole) {\n        router.push('/');\n      }\n    }, [user, isLoading, router]);\n\n    if (isLoading) {\n      return <div>Loading...</div>;\n    }\n\n    if (!user) {\n      return null;\n    }\n\n    if (requiredRole && user.role !== requiredRole) {\n      return null;\n    }\n\n    return <Component {...props} />;\n  };\n}\n```",
        "testStrategy": "1. Test user registration and login flows:\n   - Test registration with valid and invalid data\n   - Test login with correct and incorrect credentials\n   - Verify JWT token is generated correctly\n\n2. Test authentication guards and protected routes:\n   - Verify unauthenticated users are redirected to login\n   - Test role-based access control\n   - Verify JWT validation and expiration handling\n\n3. Test password security:\n   - Verify passwords are properly hashed in the database\n   - Test password comparison functionality\n   - Ensure password reset flows work correctly\n\n4. Test frontend-backend integration:\n   - Verify authentication context properly manages user state\n   - Test token storage and retrieval from localStorage\n   - Verify protected components only render for authenticated users\n\n5. Test error handling:\n   - Verify proper error messages for invalid credentials\n   - Test handling of expired tokens\n   - Verify error responses for unauthorized access attempts\n\n6. Test logout functionality:\n   - Verify user session is properly terminated\n   - Test token removal from storage\n   - Verify redirect to login page after logout",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Optional Express Backend Integration",
        "description": "Create a separate NestJS backend with Prisma integration that can be used as an alternative to Next.js API routes.",
        "status": "in-progress",
        "dependencies": [4, 6],
        "priority": "low",
        "details": "1. Create a backend directory and initialize a new NestJS project:\n```bash\nmkdir -p backend\ncd backend\nnpx @nestjs/cli new . --package-manager npm\n```\n\n2. Install dependencies for the NestJS backend:\n```bash\nnpm install @nestjs/config @nestjs/swagger @nestjs/passport passport passport-jwt passport-local @nestjs/jwt @prisma/client class-validator class-transformer helmet\nnpm install -D prisma @types/passport-jwt @types/passport-local\n```\n\n3. Configure TypeScript in `backend/tsconfig.json` (NestJS CLI will create this file with appropriate settings).\n\n4. Create a Prisma configuration in `backend/prisma/schema.prisma` (copy from the main project):\n```prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\" // or \"mongodb\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// Copy the models from the main project\n```\n\n5. Create a Prisma module and service in `backend/src/prisma`:\n\n`backend/src/prisma/prisma.service.ts`:\n```typescript\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {\n  constructor() {\n    super({\n      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n    });\n  }\n\n  async onModuleInit() {\n    await this.$connect();\n  }\n\n  async onModuleDestroy() {\n    await this.$disconnect();\n  }\n}\n```\n\n`backend/src/prisma/prisma.module.ts`:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { PrismaService } from './prisma.service';\n\n@Module({\n  providers: [PrismaService],\n  exports: [PrismaService],\n})\nexport class PrismaModule {}\n```\n\n6. Set up authentication with JWT and Passport:\n\n`backend/src/auth/auth.module.ts`:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { AuthService } from './auth.service';\nimport { AuthController } from './auth.controller';\nimport { JwtStrategy } from './strategies/jwt.strategy';\nimport { LocalStrategy } from './strategies/local.strategy';\nimport { PrismaModule } from '../prisma/prisma.module';\n\n@Module({\n  imports: [\n    PrismaModule,\n    PassportModule,\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      useFactory: async (configService: ConfigService) => ({\n        secret: configService.get<string>('JWT_SECRET'),\n        signOptions: { expiresIn: '1d' },\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n  providers: [AuthService, JwtStrategy, LocalStrategy],\n  controllers: [AuthController],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n7. Create JWT and Local strategies:\n\n`backend/src/auth/strategies/jwt.strategy.ts`:\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(private configService: ConfigService) {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: configService.get<string>('JWT_SECRET'),\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, email: payload.email };\n  }\n}\n```\n\n`backend/src/auth/strategies/local.strategy.ts`:\n```typescript\nimport { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from '../auth.service';\n\n@Injectable()\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(private authService: AuthService) {\n    super({ usernameField: 'email' });\n  }\n\n  async validate(email: string, password: string) {\n    const user = await this.authService.validateUser(email, password);\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n    return user;\n  }\n}\n```\n\n8. Create a user module and controller:\n\n`backend/src/users/users.module.ts`:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\nimport { PrismaModule } from '../prisma/prisma.module';\n\n@Module({\n  imports: [PrismaModule],\n  providers: [UsersService],\n  controllers: [UsersController],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n```\n\n`backend/src/users/users.service.ts`:\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { CreateUserDto, UpdateUserDto } from './dto';\n\n@Injectable()\nexport class UsersService {\n  constructor(private prisma: PrismaService) {}\n\n  async findAll(page = 1, pageSize = 10) {\n    const skip = (page - 1) * pageSize;\n    \n    const [users, total] = await Promise.all([\n      this.prisma.user.findMany({\n        skip,\n        take: pageSize,\n        orderBy: { createdAt: 'desc' },\n      }),\n      this.prisma.user.count(),\n    ]);\n    \n    return {\n      data: users,\n      meta: {\n        total,\n        page,\n        pageSize,\n        totalPages: Math.ceil(total / pageSize),\n      },\n    };\n  }\n\n  findOne(id: string) {\n    return this.prisma.user.findUnique({\n      where: { id },\n    });\n  }\n\n  findByEmail(email: string) {\n    return this.prisma.user.findUnique({\n      where: { email },\n    });\n  }\n\n  create(data: CreateUserDto) {\n    return this.prisma.user.create({\n      data,\n    });\n  }\n\n  update(id: string, data: UpdateUserDto) {\n    return this.prisma.user.update({\n      where: { id },\n      data,\n    });\n  }\n\n  remove(id: string) {\n    return this.prisma.user.delete({\n      where: { id },\n    });\n  }\n}\n```\n\n`backend/src/users/users.controller.ts`:\n```typescript\nimport { Controller, Get, Post, Body, Param, Put, Delete, Query, UseGuards } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { CreateUserDto, UpdateUserDto } from './dto';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\nimport { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';\n\n@ApiTags('users')\n@Controller('users')\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get all users' })\n  @ApiResponse({ status: 200, description: 'Return all users.' })\n  findAll(@Query('page') page: number, @Query('pageSize') pageSize: number) {\n    return this.usersService.findAll(page, pageSize);\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a user by id' })\n  @ApiResponse({ status: 200, description: 'Return a user.' })\n  @ApiResponse({ status: 404, description: 'User not found.' })\n  findOne(@Param('id') id: string) {\n    return this.usersService.findOne(id);\n  }\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new user' })\n  @ApiResponse({ status: 201, description: 'User successfully created.' })\n  create(@Body() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Put(':id')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Update a user' })\n  @ApiResponse({ status: 200, description: 'User successfully updated.' })\n  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {\n    return this.usersService.update(id, updateUserDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Delete(':id')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Delete a user' })\n  @ApiResponse({ status: 204, description: 'User successfully deleted.' })\n  remove(@Param('id') id: string) {\n    return this.usersService.remove(id);\n  }\n}\n```\n\n9. Set up global exception filters and validation pipes in `backend/src/main.ts`:\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { ValidationPipe } from '@nestjs/common';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport helmet from 'helmet';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  // Global validation pipe\n  app.useGlobalPipes(new ValidationPipe({\n    whitelist: true,\n    forbidNonWhitelisted: true,\n    transform: true,\n  }));\n  \n  // Security middleware\n  app.use(helmet());\n  \n  // CORS configuration\n  app.enableCors({\n    origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n    methods: ['GET', 'POST', 'PUT', 'DELETE'],\n    credentials: true,\n  });\n  \n  // Swagger documentation\n  const config = new DocumentBuilder()\n    .setTitle('API Documentation')\n    .setDescription('The API description')\n    .setVersion('1.0')\n    .addBearerAuth()\n    .build();\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);\n  \n  await app.listen(process.env.PORT || 5000);\n}\nbootstrap();\n```\n\n10. Create a `.env` file in the backend directory:\n```\nPORT=5000\nDATABASE_URL=\"postgresql://username:password@localhost:5432/mydb?schema=public\"\nJWT_SECRET=\"your-secret-key\"\nFRONTEND_URL=\"http://localhost:3000\"\n```\n\n11. Update `backend/package.json` scripts:\n```json\n{\n  \"scripts\": {\n    \"build\": \"nest build\",\n    \"format\": \"prettier --write \\\"src/**/*.ts\\\"\",\n    \"start\": \"nest start\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:debug\": \"nest start --debug --watch\",\n    \"start:prod\": \"node dist/main\",\n    \"lint\": \"eslint \\\"{src,apps,libs,test}/**/*.ts\\\" --fix\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:cov\": \"jest --coverage\",\n    \"test:debug\": \"node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand\",\n    \"test:e2e\": \"jest --config ./test/jest-e2e.json\",\n    \"prisma:generate\": \"prisma generate\",\n    \"prisma:migrate\": \"prisma migrate dev\"\n  }\n}\n```\n\n12. Create a client utility for the NestJS backend in the main project at `lib/api-client.ts`:\n```typescript\nimport { ApiError, ApiResponse } from './types';\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api';\n\nexport async function fetchFromApi<T>(\n  endpoint: string,\n  options?: RequestInit\n): Promise<ApiResponse<T>> {\n  const response = await fetch(`${API_URL}${endpoint}`, {\n    ...options,\n    headers: {\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    },\n  });\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error((data as ApiError).error || 'An error occurred');\n  }\n\n  return data as ApiResponse<T>;\n}\n```",
        "testStrategy": "1. Test NestJS server startup and connection\n2. Verify API endpoints match the Next.js API routes\n3. Test CRUD operations against a test database\n4. Verify JWT authentication and protected routes\n5. Test validation pipes and exception filters\n6. Verify Swagger documentation is accessible and accurate\n7. Test CORS and security middleware\n8. Test integration between Next.js frontend and NestJS backend\n9. Validate shared types between both systems\n10. Test performance and scalability\n11. Verify environment configuration works correctly",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Client-Side Data Fetching with React Query",
        "description": "Set up React Query for client-side data fetching, caching, and state management with TypeScript integration.",
        "details": "1. Install React Query:\n```bash\nnpm install @tanstack/react-query @tanstack/react-query-devtools\n```\n\n2. Create a React Query provider in `components/providers.tsx`:\n```typescript\n\"use client\";\n\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { ReactQueryDevtools } from \"@tanstack/react-query-devtools\";\nimport { useState, ReactNode } from \"react\";\n\nexport function Providers({ children }: { children: ReactNode }) {\n  const [queryClient] = useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            staleTime: 60 * 1000, // 1 minute\n            refetchOnWindowFocus: false,\n          },\n        },\n      })\n  );\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  );\n}\n```\n\n3. Add the React Query provider to the root layout:\n```typescript\n// app/layout.tsx\nimport { Providers } from \"@/components/providers\";\n\nexport default function RootLayout({ children }: { children: ReactNode }) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body className={cn(\n        \"min-h-screen bg-background font-sans antialiased\",\n        inter.className\n      )}>\n        <AuthProvider>\n          <ThemeProvider\n            attribute=\"class\"\n            defaultTheme=\"system\"\n            enableSystem\n            disableTransitionOnChange\n          >\n            <Providers>\n              {children}\n            </Providers>\n          </ThemeProvider>\n        </AuthProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n4. Create API hooks for users in `lib/hooks/use-users.ts`:\n```typescript\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { fetchApi } from \"@/lib/api-utils\";\nimport type { User } from \"@prisma/client\";\nimport type { ApiResponse } from \"@/lib/types\";\n\n// Get all users\nexport function useUsers(page = 1, pageSize = 10) {\n  return useQuery<ApiResponse<User[]>>({\n    queryKey: [\"users\", { page, pageSize }],\n    queryFn: () => fetchApi<User[]>(`/api/users?page=${page}&pageSize=${pageSize}`),\n  });\n}\n\n// Get user by ID\nexport function useUser(id: string) {\n  return useQuery<User>({\n    queryKey: [\"users\", id],\n    queryFn: () => fetchApi<User>(`/api/users/${id}`).then(res => res.data),\n    enabled: !!id,\n  });\n}\n\n// Create user\nexport function useCreateUser() {\n  const queryClient = useQueryClient();\n  \n  return useMutation<User, Error, Omit<User, \"id\" | \"createdAt\" | \"updatedAt\">>(\n    (newUser) => fetchApi<User>(\"/api/users\", {\n      method: \"POST\",\n      body: JSON.stringify(newUser),\n    }).then(res => res.data),\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries({ queryKey: [\"users\"] });\n      },\n    }\n  );\n}\n\n// Update user\nexport function useUpdateUser() {\n  const queryClient = useQueryClient();\n  \n  return useMutation<User, Error, { id: string; data: Partial<User> }>(\n    ({ id, data }) => fetchApi<User>(`/api/users/${id}`, {\n      method: \"PUT\",\n      body: JSON.stringify(data),\n    }).then(res => res.data),\n    {\n      onSuccess: (data) => {\n        queryClient.invalidateQueries({ queryKey: [\"users\", data.id] });\n        queryClient.invalidateQueries({ queryKey: [\"users\"] });\n      },\n    }\n  );\n}\n\n// Delete user\nexport function useDeleteUser() {\n  const queryClient = useQueryClient();\n  \n  return useMutation<void, Error, string>(\n    (id) => fetchApi<void>(`/api/users/${id}`, {\n      method: \"DELETE\",\n    }).then(() => undefined),\n    {\n      onSuccess: () => {\n        queryClient.invalidateQueries({ queryKey: [\"users\"] });\n      },\n    }\n  );\n}\n```\n\n5. Create an example users page in `app/examples/users/page.tsx`:\n```typescript\n\"use client\";\n\nimport { useState } from \"react\";\nimport { useUsers, useCreateUser, useDeleteUser } from \"@/lib/hooks/use-users\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { MainLayout } from \"@/components/layout/main-layout\";\n\nexport default function UsersPage() {\n  const [page, setPage] = useState(1);\n  const [email, setEmail] = useState(\"\");\n  const [name, setName] = useState(\"\");\n  \n  const { data, isLoading, error } = useUsers(page);\n  const createUser = useCreateUser();\n  const deleteUser = useDeleteUser();\n  \n  const handleCreateUser = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!email) return;\n    \n    try {\n      await createUser.mutateAsync({ email, name });\n      setEmail(\"\");\n      setName(\"\");\n    } catch (error) {\n      console.error(\"Error creating user:\", error);\n    }\n  };\n  \n  const handleDeleteUser = async (id: string) => {\n    try {\n      await deleteUser.mutateAsync(id);\n    } catch (error) {\n      console.error(\"Error deleting user:\", error);\n    }\n  };\n  \n  return (\n    <MainLayout>\n      <div className=\"container py-8\">\n        <h1 className=\"text-2xl font-bold mb-6\">Users Example</h1>\n        \n        <div className=\"grid gap-8 md:grid-cols-2\">\n          <div>\n            <h2 className=\"text-xl font-semibold mb-4\">Create User</h2>\n            <form onSubmit={handleCreateUser} className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"email\">Email</Label>\n                <Input\n                  id=\"email\"\n                  type=\"email\"\n                  value={email}\n                  onChange={(e) => setEmail(e.target.value)}\n                  required\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"name\">Name</Label>\n                <Input\n                  id=\"name\"\n                  type=\"text\"\n                  value={name}\n                  onChange={(e) => setName(e.target.value)}\n                />\n              </div>\n              <Button type=\"submit\" disabled={createUser.isPending}>\n                {createUser.isPending ? \"Creating...\" : \"Create User\"}\n              </Button>\n            </form>\n          </div>\n          \n          <div>\n            <h2 className=\"text-xl font-semibold mb-4\">User List</h2>\n            {isLoading ? (\n              <p>Loading...</p>\n            ) : error ? (\n              <p className=\"text-destructive\">Error loading users</p>\n            ) : (\n              <div className=\"space-y-4\">\n                <ul className=\"space-y-2\">\n                  {data?.data.map((user) => (\n                    <li key={user.id} className=\"flex items-center justify-between p-3 border rounded\">\n                      <div>\n                        <p className=\"font-medium\">{user.name || \"No name\"}</p>\n                        <p className=\"text-sm text-muted-foreground\">{user.email}</p>\n                      </div>\n                      <Button\n                        variant=\"destructive\"\n                        size=\"sm\"\n                        onClick={() => handleDeleteUser(user.id)}\n                        disabled={deleteUser.isPending}\n                      >\n                        Delete\n                      </Button>\n                    </li>\n                  ))}\n                </ul>\n                \n                {data?.data.length === 0 && (\n                  <p className=\"text-center text-muted-foreground\">No users found</p>\n                )}\n                \n                {data?.meta?.totalPages && data.meta.totalPages > 1 && (\n                  <div className=\"flex justify-center space-x-2 mt-4\">\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      onClick={() => setPage((p) => Math.max(p - 1, 1))}\n                      disabled={page === 1}\n                    >\n                      Previous\n                    </Button>\n                    <span className=\"py-2 px-3 text-sm\">\n                      Page {page} of {data.meta.totalPages}\n                    </span>\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      onClick={() => setPage((p) => p + 1)}\n                      disabled={page >= data.meta.totalPages}\n                    >\n                      Next\n                    </Button>\n                  </div>\n                )}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </MainLayout>\n  );\n}\n```",
        "testStrategy": "1. Test React Query hooks with mock API responses\n2. Verify data fetching, caching, and invalidation\n3. Test optimistic updates and error handling\n4. Verify pagination works correctly\n5. Test form submission and data mutations\n6. Validate that the React Query DevTools are working\n7. Test performance with larger datasets\n8. Verify TypeScript integration and type safety",
        "priority": "medium",
        "dependencies": [5, 6],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create Documentation and Example Pages",
        "description": "Develop comprehensive documentation and example pages showcasing different rendering strategies, API usage, and component patterns.",
        "details": "1. Create a README.md file in the project root:\n```markdown\n# Next.js TypeScript Template\n\nA modern, full-stack web application template built with Next.js 14+, TypeScript, Prisma ORM, and Tailwind CSS.\n\n## Features\n\n- **Next.js 14+ App Router**: File-based routing with support for SSR, SSG, and server components\n- **TypeScript**: Full type safety across frontend and backend\n- **Prisma ORM**: Type-safe database operations with PostgreSQL (or other databases)\n- **Tailwind CSS & shadcn/ui**: Utility-first CSS and component library\n- **Authentication**: Built-in authentication with NextAuth.js\n- **API Routes**: RESTful API endpoints with Next.js API routes\n- **Optional Express Backend**: Support for a separate Node.js/Express backend\n- **React Query**: Client-side data fetching and state management\n- **Code Quality**: ESLint, Prettier, Husky, and lint-staged\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 18.x or higher\n- npm or yarn\n- PostgreSQL, MongoDB, or other database\n\n### Installation\n\n1. Clone the repository:\n\n```bash\ngit clone https://github.com/yourusername/nextjs-typescript-template.git\ncd nextjs-typescript-template\n```\n\n2. Install dependencies:\n\n```bash\nnpm install\n```\n\n3. Set up environment variables:\n\nCreate a `.env` file in the root directory with the following variables:\n\n```\nDATABASE_URL=\"postgresql://username:password@localhost:5432/mydb?schema=public\"\nNEXTAUTH_SECRET=\"your-nextauth-secret\"\n```\n\n4. Initialize the database:\n\n```bash\nnpx prisma migrate dev --name init\n```\n\n5. Start the development server:\n\n```bash\nnpm run dev\n```\n\n## Project Structure\n\n```\n├── app/                  # Next.js App Router\n│   ├── api/              # API routes\n│   ├── auth/             # Authentication pages\n│   ├── examples/         # Example pages\n│   ├── layout.tsx        # Root layout\n│   └── page.tsx          # Home page\n├── components/           # React components\n│   ├── ui/               # UI components (shadcn/ui)\n│   ├── layout/           # Layout components\n│   └── forms/            # Form components\n├── lib/                  # Shared utilities\n│   ├── hooks/            # Custom React hooks\n│   ├── prisma.ts         # Prisma client\n│   └── utils.ts          # Helper functions\n├── prisma/               # Prisma schema and migrations\n├── public/               # Static assets\n└── backend/              # Optional Express backend\n```\n\n## Documentation\n\n### Rendering Strategies\n\nThis template supports multiple rendering strategies:\n\n- **Server-Side Rendering (SSR)**: Dynamic data fetching on each request\n- **Static Site Generation (SSG)**: Pre-rendered at build time\n- **Incremental Static Regeneration (ISR)**: Static generation with revalidation\n- **Client-Side Rendering**: Data fetching in the browser\n\nExample usage can be found in the `/app/examples` directory.\n\n### Database Operations\n\nPrisma ORM is used for database operations. The schema is defined in `prisma/schema.prisma`.\n\nExample usage:\n\n```typescript\nimport { prisma } from '@/lib/prisma';\n\n// Get all users\nconst users = await prisma.user.findMany();\n\n// Create a user\nconst user = await prisma.user.create({\n  data: {\n    email: 'user@example.com',\n    name: 'John Doe',\n  },\n});\n```\n\n### API Routes\n\nAPI routes are defined in the `/app/api` directory using Next.js App Router route handlers.\n\nExample usage:\n\n```typescript\n// app/api/users/route.ts\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\n\nexport async function GET() {\n  const users = await prisma.user.findMany();\n  return NextResponse.json(users);\n}\n```\n\n### Authentication\n\nAuthentication is implemented using NextAuth.js. Configuration is in `/app/api/auth/[...nextauth]/route.ts`.\n\nExample usage:\n\n```typescript\n// Client component\nimport { useSession, signIn, signOut } from 'next-auth/react';\n\nexport default function AuthButton() {\n  const { data: session } = useSession();\n  \n  if (session) {\n    return (\n      <button onClick={() => signOut()}>Sign out</button>\n    );\n  }\n  return (\n    <button onClick={() => signIn()}>Sign in</button>\n  );\n}\n```\n\n## Hybrid Backend Approach\n\nThis template supports two backend approaches:\n\n1. **Next.js API Routes**: Built-in API routes for simpler applications\n2. **Express Backend**: Separate Express server for more complex backends\n\nTo use the Express backend:\n\n1. Navigate to the backend directory:\n\n```bash\ncd backend\n```\n\n2. Install dependencies:\n\n```bash\nnpm install\n```\n\n3. Start the development server:\n\n```bash\nnpm run dev\n```\n\n## Deployment\n\n### Next.js Frontend\n\nThe Next.js application can be deployed to Vercel:\n\n```bash\nnpx vercel\n```\n\n### Express Backend\n\nThe Express backend can be deployed to services like Render or Railway.\n\n## License\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n```\n\n2. Create an examples directory with different rendering strategies:\n\n- Create a Server-Side Rendering example in `app/examples/ssr/page.tsx`:\n```typescript\nimport { MainLayout } from \"@/components/layout/main-layout\";\nimport { prisma } from \"@/lib/prisma\";\n\nexport const dynamic = 'force-dynamic';\n\nexport default async function SSRPage() {\n  // This data is fetched on each request (SSR)\n  const users = await prisma.user.findMany({\n    take: 5,\n    orderBy: { createdAt: 'desc' },\n  });\n  \n  return (\n    <MainLayout>\n      <div className=\"container py-8\">\n        <h1 className=\"text-2xl font-bold mb-6\">Server-Side Rendering Example</h1>\n        <p className=\"mb-4 text-muted-foreground\">\n          This page uses Server-Side Rendering (SSR) to fetch data on each request.\n          Refresh the page to see that the timestamp updates.\n        </p>\n        \n        <div className=\"p-4 border rounded-md mb-6\">\n          <p className=\"font-mono text-sm\">Rendered at: {new Date().toISOString()}</p>\n        </div>\n        \n        <h2 className=\"text-xl font-semibold mb-4\">Recent Users</h2>\n        <ul className=\"space-y-2\">\n          {users.map((user) => (\n            <li key={user.id} className=\"p-3 border rounded\">\n              <p className=\"font-medium\">{user.name || \"No name\"}</p>\n              <p className=\"text-sm text-muted-foreground\">{user.email}</p>\n            </li>\n          ))}\n        </ul>\n      </div>\n    </MainLayout>\n  );\n}\n```\n\n- Create a Static Site Generation example in `app/examples/ssg/page.tsx`:\n```typescript\nimport { MainLayout } from \"@/components/layout/main-layout\";\n\nexport const dynamic = 'force-static';\n\nexport default function SSGPage() {\n  // This page is generated at build time (SSG)\n  return (\n    <MainLayout>\n      <div className=\"container py-8\">\n        <h1 className=\"text-2xl font-bold mb-6\">Static Site Generation Example</h1>\n        <p className=\"mb-4 text-muted-foreground\">\n          This page uses Static Site Generation (SSG) and is generated at build time.\n          The timestamp below will not change on refresh.\n        </p>\n        \n        <div className=\"p-4 border rounded-md\">\n          <p className=\"font-mono text-sm\">Built at: {new Date().toISOString()}</p>\n        </div>\n      </div>\n    </MainLayout>\n  );\n}\n```\n\n- Create an Incremental Static Regeneration example in `app/examples/isr/page.tsx`:\n```typescript\nimport { MainLayout } from \"@/components/layout/main-layout\";\n\nexport const revalidate = 60; // Revalidate every 60 seconds\n\nexport default function ISRPage() {\n  // This page uses Incremental Static Regeneration (ISR)\n  return (\n    <MainLayout>\n      <div className=\"container py-8\">\n        <h1 className=\"text-2xl font-bold mb-6\">Incremental Static Regeneration Example</h1>\n        <p className=\"mb-4 text-muted-foreground\">\n          This page uses Incremental Static Regeneration (ISR) with a revalidation period of 60 seconds.\n          The timestamp will update after the revalidation period.\n        </p>\n        \n        <div className=\"p-4 border rounded-md\">\n          <p className=\"font-mono text-sm\">Generated at: {new Date().toISOString()}</p>\n        </div>\n      </div>\n    </MainLayout>\n  );\n}\n```\n\n3. Create an examples index page in `app/examples/page.tsx`:\n```typescript\nimport Link from \"next/link\";\nimport { MainLayout } from \"@/components/layout/main-layout\";\nimport { Button } from \"@/components/ui/button\";\n\nexport default function ExamplesPage() {\n  return (\n    <MainLayout>\n      <div className=\"container py-8\">\n        <h1 className=\"text-2xl font-bold mb-6\">Examples</h1>\n        <p className=\"mb-8 text-muted-foreground\">\n          Explore different features and patterns implemented in this template.\n        </p>\n        \n        <div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-3\">\n          <ExampleCard\n            title=\"Server-Side Rendering\"\n            description=\"Example of fetching data on each request using SSR.\"\n            href=\"/examples/ssr\"\n          />\n          <ExampleCard\n            title=\"Static Site Generation\"\n            description=\"Example of pre-rendering pages at build time using SSG.\"\n            href=\"/examples/ssg\"\n          />\n          <ExampleCard\n            title=\"Incremental Static Regeneration\"\n            description=\"Example of static generation with revalidation using ISR.\"\n            href=\"/examples/isr\"\n          />\n          <ExampleCard\n            title=\"Client-Side Data Fetching\"\n            description=\"Example of fetching data in the browser using React Query.\"\n            href=\"/examples/users\"\n          />\n          <ExampleCard\n            title=\"Form Handling\"\n            description=\"Example of form validation and submission.\"\n            href=\"/examples/form\"\n          />\n          <ExampleCard\n            title=\"Authentication\"\n            description=\"Example of protected routes and user authentication.\"\n            href=\"/examples/auth\"\n          />\n        </div>\n      </div>\n    </MainLayout>\n  );\n}\n\nfunction ExampleCard({ title, description, href }: { title: string; description: string; href: string }) {\n  return (\n    <div className=\"rounded-lg border bg-card text-card-foreground shadow-sm\">\n      <div className=\"p-6 flex flex-col h-full\">\n        <h3 className=\"text-lg font-semibold\">{title}</h3>\n        <p className=\"mt-2 text-sm text-muted-foreground flex-grow\">{description}</p>\n        <div className=\"mt-4\">\n          <Button asChild>\n            <Link href={href}>View Example</Link>\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n4. Create a form example in `app/examples/form/page.tsx`:\n```typescript\n\"use client\";\n\nimport { useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { MainLayout } from \"@/components/layout/main-layout\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Label } from \"@/components/ui/label\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\n\nconst formSchema = z.object({\n  name: z.string().min(2, { message: \"Name must be at least 2 characters\" }),\n  email: z.string().email({ message: \"Invalid email address\" }),\n  message: z.string().min(10, { message: \"Message must be at least 10 characters\" }),\n});\n\ntype FormValues = z.infer<typeof formSchema>;\n\nexport default function FormPage() {\n  const [isSubmitted, setIsSubmitted] = useState(false);\n  \n  const {\n    register,\n    handleSubmit,\n    reset,\n    formState: { errors, isSubmitting },\n  } = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      name: \"\",\n      email: \"\",\n      message: \"\",\n    },\n  });\n  \n  const onSubmit = async (data: FormValues) => {\n    // Simulate API call\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    console.log(\"Form submitted:\", data);\n    reset();\n    setIsSubmitted(true);\n  };\n  \n  return (\n    <MainLayout>\n      <div className=\"container py-8 max-w-md mx-auto\">\n        <h1 className=\"text-2xl font-bold mb-6\">Form Example</h1>\n        \n        {isSubmitted ? (\n          <div className=\"space-y-4\">\n            <Alert className=\"bg-green-50 border-green-200\">\n              <AlertDescription className=\"text-green-800\">\n                Form submitted successfully!\n              </AlertDescription>\n            </Alert>\n            <Button onClick={() => setIsSubmitted(false)}>Submit Another</Button>\n          </div>\n        ) : (\n          <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-6\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"name\">Name</Label>\n              <Input id=\"name\" {...register(\"name\")} />\n              {errors.name && (\n                <p className=\"text-sm text-destructive\">{errors.name.message}</p>\n              )}\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"email\">Email</Label>\n              <Input id=\"email\" type=\"email\" {...register(\"email\")} />\n              {errors.email && (\n                <p className=\"text-sm text-destructive\">{errors.email.message}</p>\n              )}\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"message\">Message</Label>\n              <Textarea id=\"message\" rows={5} {...register(\"message\")} />\n              {errors.message && (\n                <p className=\"text-sm text-destructive\">{errors.message.message}</p>\n              )}\n            </div>\n            \n            <Button type=\"submit\" className=\"w-full\" disabled={isSubmitting}>\n              {isSubmitting ? \"Submitting...\" : \"Submit\"}\n            </Button>\n          </form>\n        )}\n      </div>\n    </MainLayout>\n  );\n}\n```",
        "testStrategy": "1. Verify all example pages render correctly without errors\n2. Test documentation accuracy by following the setup instructions\n3. Validate that all rendering strategies work as described\n4. Test form validation and submission in the form example\n5. Verify that the README contains all necessary information\n6. Test navigation between example pages\n7. Validate code snippets in the documentation\n8. Ensure all examples are accessible and responsive",
        "priority": "low",
        "dependencies": [5, 6, 7, 9],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Set Up OAuth Providers for Authentication",
        "description": "Configure NextAuth.js with multiple OAuth providers (Google, GitHub, etc.) for social login functionality, including environment setup, UI components, and database integration.",
        "details": "1. Add OAuth provider configurations to NextAuth.js setup in `app/api/auth/[...nextauth]/route.ts`:\n```typescript\nimport NextAuth from \"next-auth\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { prisma } from \"@/lib/prisma\";\nimport GoogleProvider from \"next-auth/providers/google\";\nimport GitHubProvider from \"next-auth/providers/github\";\n// Import other providers as needed\n\nexport const authOptions = {\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    }),\n    GitHubProvider({\n      clientId: process.env.GITHUB_ID!,\n      clientSecret: process.env.GITHUB_SECRET!,\n    }),\n    // Add other providers as needed\n  ],\n  callbacks: {\n    async session({ session, user }) {\n      // Add user ID to session\n      if (session.user) {\n        session.user.id = user.id;\n      }\n      return session;\n    },\n    // Add other callbacks as needed\n  },\n  pages: {\n    signIn: '/auth/signin',\n    // Customize other pages as needed\n  },\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\n\n2. Set up environment variables in `.env.local`:\n```\n# OAuth Providers\nGOOGLE_CLIENT_ID=your-google-client-id\nGOOGLE_CLIENT_SECRET=your-google-client-secret\nGITHUB_ID=your-github-client-id\nGITHUB_SECRET=your-github-client-secret\n# Add other provider credentials as needed\n\n# NextAuth.js\nNEXTAUTH_URL=http://localhost:3000\nNEXTAUTH_SECRET=your-nextauth-secret\n```\n\n3. Create provider-specific login buttons in `app/auth/signin/page.tsx`:\n```typescript\n\"use client\";\n\nimport { signIn } from \"next-auth/react\";\nimport { Button } from \"@/components/ui/button\";\nimport { FaGoogle, FaGithub } from \"react-icons/fa\";\n\nexport default function SignIn() {\n  return (\n    <div className=\"flex flex-col space-y-4 max-w-sm mx-auto mt-10\">\n      <h1 className=\"text-2xl font-bold text-center\">Sign In</h1>\n      \n      <Button \n        variant=\"outline\" \n        onClick={() => signIn(\"google\", { callbackUrl: \"/\" })}\n        className=\"flex items-center justify-center gap-2\"\n      >\n        <FaGoogle className=\"h-4 w-4\" />\n        Sign in with Google\n      </Button>\n      \n      <Button \n        variant=\"outline\" \n        onClick={() => signIn(\"github\", { callbackUrl: \"/\" })}\n        className=\"flex items-center justify-center gap-2\"\n      >\n        <FaGithub className=\"h-4 w-4\" />\n        Sign in with GitHub\n      </Button>\n      \n      {/* Add other provider buttons as needed */}\n    </div>\n  );\n}\n```\n\n4. Create a custom session type in `types/next-auth.d.ts`:\n```typescript\nimport NextAuth from \"next-auth\";\n\ndeclare module \"next-auth\" {\n  interface Session {\n    user: {\n      id: string;\n      name?: string | null;\n      email?: string | null;\n      image?: string | null;\n    };\n  }\n}\n```\n\n5. Update the Prisma schema to ensure it has all necessary fields for OAuth providers in `prisma/schema.prisma`:\n```prisma\nmodel Account {\n  id                String  @id @default(cuid())\n  userId            String\n  type              String\n  provider          String\n  providerAccountId String\n  refresh_token     String? @db.Text\n  access_token      String? @db.Text\n  expires_at        Int?\n  token_type        String?\n  scope             String?\n  id_token          String? @db.Text\n  session_state     String?\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n}\n```\n\n6. Create a provider registration guide in the documentation:\n   - Instructions for creating OAuth applications in Google Cloud Console\n   - Instructions for creating OAuth apps in GitHub Developer Settings\n   - Steps for obtaining client IDs and secrets\n   - Security best practices for handling OAuth credentials\n\n7. Implement a user profile page that displays OAuth account connections in `app/profile/page.tsx`\n\n8. Add error handling for OAuth authentication failures with appropriate user feedback",
        "testStrategy": "1. Test OAuth sign-in flow with each provider:\n   - Verify successful authentication with Google\n   - Verify successful authentication with GitHub\n   - Test any other configured providers\n\n2. Test error handling:\n   - Test behavior when OAuth provider is unavailable\n   - Test with invalid credentials in environment variables\n   - Test user cancellation during OAuth flow\n\n3. Verify database integration:\n   - Confirm user accounts are created in the database after OAuth sign-in\n   - Verify account linking if a user signs in with multiple providers\n   - Check that all OAuth-specific fields are properly stored\n\n4. Test session management:\n   - Verify session persistence after OAuth login\n   - Test session expiration and renewal\n   - Confirm user ID is properly included in the session\n\n5. UI testing:\n   - Verify OAuth buttons render correctly on different screen sizes\n   - Test accessibility of OAuth login components\n   - Verify loading states during authentication\n\n6. Security testing:\n   - Verify CSRF protection is working\n   - Test that OAuth state parameter is validated\n   - Ensure sensitive OAuth tokens are not exposed to the client\n\n7. End-to-end testing:\n   - Complete full OAuth flow from login to protected page access\n   - Test logout functionality after OAuth login",
        "status": "pending",
        "dependencies": [4, 7],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Email Verification for User Registration",
        "description": "Set up a complete email verification system for user registration, including email service integration, verification tokens, sending emails, and handling verification endpoints.",
        "details": "1. Set up email service integration:\n```bash\n# Install email service SDK (example using SendGrid)\nnpm install @sendgrid/mail\n# Or for Resend\nnpm install resend\n```\n\n2. Create environment variables in `.env`:\n```\n# For SendGrid\nSENDGRID_API_KEY=your_api_key\n# Or for Resend\nRESEND_API_KEY=your_api_key\nEMAIL_FROM=noreply@yourdomain.com\n```\n\n3. Create an email service utility in `lib/email.ts`:\n```typescript\n// Using SendGrid example\nimport sgMail from '@sendgrid/mail';\n\nsgMail.setApiKey(process.env.SENDGRID_API_KEY!);\n\nexport async function sendVerificationEmail(to: string, token: string) {\n  const verificationUrl = `${process.env.NEXTAUTH_URL}/verify-email?token=${token}`;\n  \n  const msg = {\n    to,\n    from: process.env.EMAIL_FROM!,\n    subject: 'Verify your email address',\n    text: `Please verify your email by clicking on the following link: ${verificationUrl}`,\n    html: `\n      <div>\n        <h1>Email Verification</h1>\n        <p>Please verify your email by clicking on the link below:</p>\n        <a href=\"${verificationUrl}\">Verify Email</a>\n      </div>\n    `,\n  };\n  \n  return sgMail.send(msg);\n}\n```\n\n4. Update Prisma schema to support verification tokens in `prisma/schema.prisma`:\n```prisma\nmodel User {\n  id            String    @id @default(cuid())\n  name          String?\n  email         String?   @unique\n  emailVerified DateTime?\n  image         String?\n  password      String?\n  accounts      Account[]\n  sessions      Session[]\n  verificationTokens VerificationToken[]\n}\n\nmodel VerificationToken {\n  id        String   @id @default(cuid())\n  token     String   @unique\n  expires   DateTime\n  userId    String\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n  createdAt DateTime @default(now())\n\n  @@index([userId])\n}\n```\n\n5. Run Prisma migration:\n```bash\nnpx prisma migrate dev --name add_verification_tokens\n```\n\n6. Create a token generation utility in `lib/tokens.ts`:\n```typescript\nimport { randomBytes } from 'crypto';\nimport { prisma } from './prisma';\n\nexport async function generateVerificationToken(userId: string) {\n  // Delete any existing tokens for this user\n  await prisma.verificationToken.deleteMany({\n    where: { userId }\n  });\n  \n  // Generate a new token\n  const token = randomBytes(32).toString('hex');\n  const expires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours\n  \n  // Save the token\n  const verificationToken = await prisma.verificationToken.create({\n    data: {\n      token,\n      expires,\n      userId\n    }\n  });\n  \n  return verificationToken.token;\n}\n```\n\n7. Update the registration API route to send verification emails in `app/api/auth/register/route.ts`:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport { hash } from 'bcrypt';\nimport { generateVerificationToken } from '@/lib/tokens';\nimport { sendVerificationEmail } from '@/lib/email';\nimport { z } from 'zod';\n\nconst registerSchema = z.object({\n  name: z.string().min(2).max(100),\n  email: z.string().email(),\n  password: z.string().min(8)\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { name, email, password } = registerSchema.parse(body);\n    \n    // Check if user exists\n    const existingUser = await prisma.user.findUnique({\n      where: { email }\n    });\n    \n    if (existingUser) {\n      return NextResponse.json(\n        { error: 'Email already in use' },\n        { status: 400 }\n      );\n    }\n    \n    // Hash password\n    const hashedPassword = await hash(password, 10);\n    \n    // Create user\n    const user = await prisma.user.create({\n      data: {\n        name,\n        email,\n        password: hashedPassword\n      }\n    });\n    \n    // Generate verification token\n    const verificationToken = await generateVerificationToken(user.id);\n    \n    // Send verification email\n    await sendVerificationEmail(email, verificationToken);\n    \n    return NextResponse.json(\n      { message: 'User created. Please verify your email.' },\n      { status: 201 }\n    );\n  } catch (error) {\n    console.error('Registration error:', error);\n    return NextResponse.json(\n      { error: 'Invalid request or server error' },\n      { status: 400 }\n    );\n  }\n}\n```\n\n8. Create an API endpoint for verifying tokens in `app/api/auth/verify/route.ts`:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\n\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const token = searchParams.get('token');\n    \n    if (!token) {\n      return NextResponse.json(\n        { error: 'Missing token' },\n        { status: 400 }\n      );\n    }\n    \n    // Find the token\n    const verificationToken = await prisma.verificationToken.findUnique({\n      where: { token },\n      include: { user: true }\n    });\n    \n    if (!verificationToken) {\n      return NextResponse.json(\n        { error: 'Invalid token' },\n        { status: 400 }\n      );\n    }\n    \n    // Check if token is expired\n    if (verificationToken.expires < new Date()) {\n      return NextResponse.json(\n        { error: 'Token expired' },\n        { status: 400 }\n      );\n    }\n    \n    // Update user's email verification status\n    await prisma.user.update({\n      where: { id: verificationToken.userId },\n      data: { emailVerified: new Date() }\n    });\n    \n    // Delete the token\n    await prisma.verificationToken.delete({\n      where: { id: verificationToken.id }\n    });\n    \n    return NextResponse.json(\n      { message: 'Email verified successfully' },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('Verification error:', error);\n    return NextResponse.json(\n      { error: 'Server error' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n9. Create a verification page in `app/verify-email/page.tsx`:\n```typescript\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useSearchParams, useRouter } from 'next/navigation';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport default function VerifyEmailPage() {\n  const searchParams = useSearchParams();\n  const router = useRouter();\n  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');\n  const [message, setMessage] = useState('Verifying your email...');\n  \n  useEffect(() => {\n    const token = searchParams.get('token');\n    \n    if (!token) {\n      setStatus('error');\n      setMessage('Missing verification token');\n      return;\n    }\n    \n    const verifyEmail = async () => {\n      try {\n        const response = await fetch(`/api/auth/verify?token=${token}`);\n        const data = await response.json();\n        \n        if (response.ok) {\n          setStatus('success');\n          setMessage(data.message || 'Email verified successfully');\n        } else {\n          setStatus('error');\n          setMessage(data.error || 'Failed to verify email');\n        }\n      } catch (error) {\n        setStatus('error');\n        setMessage('An error occurred during verification');\n      }\n    };\n    \n    verifyEmail();\n  }, [searchParams]);\n  \n  return (\n    <div className=\"flex justify-center items-center min-h-screen p-4\">\n      <Card className=\"w-full max-w-md\">\n        <CardHeader>\n          <CardTitle>Email Verification</CardTitle>\n          <CardDescription>\n            {status === 'loading' ? 'Processing your verification request' : \n             status === 'success' ? 'Your email has been verified' : \n             'Verification failed'}\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <p className=\"text-center\">{message}</p>\n        </CardContent>\n        <CardFooter className=\"flex justify-center\">\n          {status !== 'loading' && (\n            <Button onClick={() => router.push('/login')}>\n              Go to Login\n            </Button>\n          )}\n        </CardFooter>\n      </Card>\n    </div>\n  );\n}\n```\n\n10. Update NextAuth.js configuration to check for email verification in `app/api/auth/[...nextauth]/route.ts`:\n```typescript\nimport NextAuth, { NextAuthOptions } from \"next-auth\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { prisma } from \"@/lib/prisma\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport { compare } from \"bcrypt\";\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    CredentialsProvider({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n        \n        const user = await prisma.user.findUnique({\n          where: { email: credentials.email }\n        });\n        \n        if (!user || !user.password) {\n          return null;\n        }\n        \n        // Check if email is verified\n        if (!user.emailVerified) {\n          throw new Error(\"Please verify your email before logging in\");\n        }\n        \n        const isPasswordValid = await compare(credentials.password, user.password);\n        \n        if (!isPasswordValid) {\n          return null;\n        }\n        \n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name\n        };\n      }\n    })\n    // Add other providers as needed\n  ],\n  callbacks: {\n    async session({ session, user }) {\n      if (session.user) {\n        session.user.id = user.id;\n      }\n      return session;\n    }\n  },\n  pages: {\n    signIn: '/login',\n    error: '/login'\n  },\n  session: {\n    strategy: \"jwt\"\n  }\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\n\n11. Add a resend verification email functionality in `app/api/auth/resend-verification/route.ts`:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport { generateVerificationToken } from '@/lib/tokens';\nimport { sendVerificationEmail } from '@/lib/email';\nimport { z } from 'zod';\n\nconst resendSchema = z.object({\n  email: z.string().email()\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { email } = resendSchema.parse(body);\n    \n    const user = await prisma.user.findUnique({\n      where: { email }\n    });\n    \n    if (!user) {\n      // Return success even if user doesn't exist for security\n      return NextResponse.json(\n        { message: 'Verification email sent if account exists' },\n        { status: 200 }\n      );\n    }\n    \n    if (user.emailVerified) {\n      return NextResponse.json(\n        { message: 'Email already verified' },\n        { status: 400 }\n      );\n    }\n    \n    // Generate new verification token\n    const verificationToken = await generateVerificationToken(user.id);\n    \n    // Send verification email\n    await sendVerificationEmail(email, verificationToken);\n    \n    return NextResponse.json(\n      { message: 'Verification email sent' },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('Resend verification error:', error);\n    return NextResponse.json(\n      { error: 'Invalid request or server error' },\n      { status: 400 }\n    );\n  }\n}\n```\n\n12. Create a component for resending verification emails in `components/resend-verification.tsx`:\n```typescript\n'use client';\n\nimport { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\n\nexport function ResendVerificationForm() {\n  const [email, setEmail] = useState('');\n  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');\n  const [message, setMessage] = useState('');\n  \n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setStatus('loading');\n    \n    try {\n      const response = await fetch('/api/auth/resend-verification', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email })\n      });\n      \n      const data = await response.json();\n      \n      if (response.ok) {\n        setStatus('success');\n        setMessage(data.message || 'Verification email sent');\n      } else {\n        setStatus('error');\n        setMessage(data.error || 'Failed to send verification email');\n      }\n    } catch (error) {\n      setStatus('error');\n      setMessage('An error occurred');\n    }\n  };\n  \n  return (\n    <Card className=\"w-full max-w-md\">\n      <CardHeader>\n        <CardTitle>Resend Verification Email</CardTitle>\n        <CardDescription>\n          Enter your email to receive a new verification link\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        {status === 'success' || status === 'error' ? (\n          <Alert variant={status === 'success' ? 'default' : 'destructive'}>\n            <AlertDescription>{message}</AlertDescription>\n          </Alert>\n        ) : null}\n        \n        <form onSubmit={handleSubmit} className=\"space-y-4 mt-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"email\">Email</Label>\n            <Input\n              id=\"email\"\n              type=\"email\"\n              value={email}\n              onChange={(e) => setEmail(e.target.value)}\n              placeholder=\"your@email.com\"\n              required\n            />\n          </div>\n          \n          <Button \n            type=\"submit\" \n            className=\"w-full\" \n            disabled={status === 'loading'}\n          >\n            {status === 'loading' ? 'Sending...' : 'Resend Verification Email'}\n          </Button>\n        </form>\n      </CardContent>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Test email service integration:\n   - Verify API keys are correctly configured in environment variables\n   - Test the email sending utility with a test email address\n   - Verify email content and formatting is correct\n\n2. Test verification token generation:\n   - Verify tokens are generated with correct expiration times\n   - Test that old tokens are deleted when new ones are created\n   - Verify token uniqueness\n\n3. Test user registration with email verification:\n   - Register a new user and confirm verification email is sent\n   - Check database to confirm user is created with emailVerified set to null\n   - Verify verification token is created in the database\n\n4. Test email verification process:\n   - Test verification endpoint with valid tokens\n   - Test with expired tokens\n   - Test with invalid tokens\n   - Verify user's emailVerified field is updated after successful verification\n\n5. Test login with verification requirement:\n   - Attempt to login with unverified email (should be rejected)\n   - Verify user with verified email can login successfully\n   - Test error messages for unverified accounts\n\n6. Test resend verification functionality:\n   - Test resending verification email for existing unverified users\n   - Test with already verified users\n   - Test with non-existent email addresses\n   - Verify new token is generated when resending\n\n7. Test verification UI:\n   - Test verification page with valid token parameter\n   - Test with invalid/expired token\n   - Test with missing token\n   - Verify proper success/error messages are displayed\n\n8. Integration testing:\n   - Test the complete flow from registration to verification to login\n   - Verify NextAuth.js integration works correctly with email verification\n   - Test that protected routes remain inaccessible until email is verified\n\n9. Security testing:\n   - Verify tokens are properly invalidated after use\n   - Test for timing attacks by ensuring consistent response times\n   - Verify proper error handling without leaking sensitive information",
        "status": "pending",
        "dependencies": [4, 6, 7],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Create Comprehensive API Documentation",
        "description": "Implement complete API documentation using Swagger/OpenAPI, including endpoint details, request/response examples, authentication requirements, versioning strategy, and interactive documentation.",
        "details": "1. Install Swagger/OpenAPI dependencies:\n```bash\nnpm install swagger-jsdoc swagger-ui-express\nnpm install -D @types/swagger-jsdoc @types/swagger-ui-express\n```\n\n2. Create a Swagger configuration file in `lib/swagger.ts`:\n```typescript\nimport swaggerJsdoc from 'swagger-jsdoc';\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'Next.js TypeScript API',\n      version: '1.0.0',\n      description: 'API documentation for the Next.js TypeScript Template',\n      license: {\n        name: 'MIT',\n        url: 'https://opensource.org/licenses/MIT',\n      },\n      contact: {\n        name: 'API Support',\n        email: 'support@example.com',\n      },\n    },\n    servers: [\n      {\n        url: process.env.NODE_ENV === 'production' \n          ? 'https://your-production-domain.com/api' \n          : 'http://localhost:3000/api',\n        description: process.env.NODE_ENV === 'production' ? 'Production server' : 'Development server',\n      },\n    ],\n    components: {\n      securitySchemes: {\n        bearerAuth: {\n          type: 'http',\n          scheme: 'bearer',\n          bearerFormat: 'JWT',\n        },\n      },\n    },\n  },\n  apis: ['./app/api/**/*.ts', './app/api/**/route.ts'],\n};\n\nconst specs = swaggerJsdoc(options);\nexport default specs;\n```\n\n3. Create a Swagger UI API route in `app/api/docs/route.ts`:\n```typescript\nimport { NextResponse } from 'next/server';\nimport swaggerUi from 'swagger-ui-express';\nimport specs from '@/lib/swagger';\n\nexport async function GET() {\n  const html = swaggerUi.generateHTML(specs);\n  return new NextResponse(html, {\n    headers: {\n      'Content-Type': 'text/html',\n    },\n  });\n}\n```\n\n4. Document API endpoints using JSDoc comments. Example for users API:\n```typescript\n/**\n * @swagger\n * /api/users:\n *   get:\n *     summary: Retrieve a list of users\n *     description: Returns a paginated list of users\n *     tags: [Users]\n *     parameters:\n *       - in: query\n *         name: page\n *         schema:\n *           type: integer\n *           default: 1\n *         description: Page number\n *       - in: query\n *         name: pageSize\n *         schema:\n *           type: integer\n *           default: 10\n *         description: Number of items per page\n *     responses:\n *       200:\n *         description: A list of users\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 users:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/User'\n *                 pagination:\n *                   $ref: '#/components/schemas/Pagination'\n *       500:\n *         description: Server error\n */\nexport async function GET(request: Request) {\n  // Implementation...\n}\n```\n\n5. Define reusable schemas in the Swagger configuration:\n```typescript\n/**\n * @swagger\n * components:\n *   schemas:\n *     User:\n *       type: object\n *       required:\n *         - id\n *         - email\n *       properties:\n *         id:\n *           type: string\n *           description: The auto-generated ID of the user\n *         email:\n *           type: string\n *           description: The user's email\n *         name:\n *           type: string\n *           description: The user's name\n *         createdAt:\n *           type: string\n *           format: date-time\n *           description: When the user was created\n *       example:\n *         id: \"clb3x0n9h0000qsjs1ckr2e4m\"\n *         email: \"user@example.com\"\n *         name: \"John Doe\"\n *         createdAt: \"2023-01-01T00:00:00.000Z\"\n *     Pagination:\n *       type: object\n *       properties:\n *         total:\n *           type: integer\n *           description: Total number of items\n *         pages:\n *           type: integer\n *           description: Total number of pages\n *         page:\n *           type: integer\n *           description: Current page\n *         pageSize:\n *           type: integer\n *           description: Number of items per page\n */\n```\n\n6. Document authentication requirements:\n```typescript\n/**\n * @swagger\n * /api/users/{id}:\n *   get:\n *     summary: Get a user by ID\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *         description: User ID\n *     responses:\n *       200:\n *         description: User details\n *       401:\n *         description: Unauthorized\n *       404:\n *         description: User not found\n */\n```\n\n7. Create an API versioning strategy:\n   - Implement versioning in the URL path: `/api/v1/users`, `/api/v2/users`\n   - Create a folder structure in the app directory: `app/api/v1/users/route.ts`\n   - Document version differences in the API documentation\n\n8. Add a documentation page in `app/docs/page.tsx`:\n```typescript\n\"use client\";\n\nimport { useEffect } from 'react';\n\nexport default function DocsPage() {\n  useEffect(() => {\n    // Redirect to the Swagger UI\n    window.location.href = '/api/docs';\n  }, []);\n\n  return <div>Redirecting to API documentation...</div>;\n}\n```\n\n9. Create a middleware to protect the API documentation in production:\n```typescript\n// In middleware.ts\nexport function middleware(request: NextRequest) {\n  // Only in production\n  if (process.env.NODE_ENV === 'production') {\n    const apiDocsPath = '/api/docs';\n    \n    if (request.nextUrl.pathname.startsWith(apiDocsPath)) {\n      // Implement basic auth or other protection mechanism\n      const authHeader = request.headers.get('authorization');\n      \n      if (!authHeader || !isValidAuth(authHeader)) {\n        return new NextResponse('Unauthorized', {\n          status: 401,\n          headers: {\n            'WWW-Authenticate': 'Basic realm=\"API Documentation\"',\n          },\n        });\n      }\n    }\n  }\n  \n  return NextResponse.next();\n}\n```\n\n10. Document all API endpoints, including:\n    - User management endpoints\n    - Authentication endpoints\n    - Any other business logic endpoints\n    - Error responses and status codes\n    - Request and response examples for each endpoint",
        "testStrategy": "1. Verify Swagger/OpenAPI setup:\n   - Run the application and navigate to `/api/docs` or `/docs`\n   - Confirm the Swagger UI loads correctly\n   - Check that the API specification is valid\n\n2. Test documentation completeness:\n   - Verify all API endpoints are documented\n   - Ensure each endpoint has proper descriptions, parameters, and response examples\n   - Check that authentication requirements are clearly documented\n   - Validate that all models/schemas are properly defined\n\n3. Test interactive documentation functionality:\n   - Try out API endpoints directly from the Swagger UI\n   - Verify that the \"Try it out\" feature works correctly\n   - Test authentication flow through the documentation\n   - Confirm that responses match the documented schemas\n\n4. Validate API versioning:\n   - Test accessing different API versions\n   - Verify that version differences are clearly documented\n   - Ensure backward compatibility is maintained where appropriate\n\n5. Test documentation security:\n   - In production environment, verify that documentation access is properly protected\n   - Test authentication mechanisms for accessing the documentation\n\n6. Cross-browser testing:\n   - Verify the documentation renders correctly in different browsers\n   - Test on mobile devices to ensure responsive design\n\n7. Accessibility testing:\n   - Verify the documentation meets accessibility standards\n   - Test with screen readers and keyboard navigation\n\n8. Performance testing:\n   - Measure the load time of the documentation page\n   - Ensure the documentation doesn't impact API performance\n\n9. Review with stakeholders:\n   - Have API consumers review the documentation for clarity and completeness\n   - Gather feedback on usability and make necessary improvements",
        "status": "pending",
        "dependencies": [6, 4],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Set Up Database Seeding with Realistic Test Data",
        "description": "Create and implement database seeding functionality with realistic test data for all models, including relationship handling and idempotent execution.",
        "details": "1. Install required dependencies:\n```bash\nnpm install --save-dev @faker-js/faker\n```\n\n2. Create a seed directory structure:\n```\nprisma/\n  ├── seed/\n  │   ├── index.ts       # Main seed entry point\n  │   ├── users.ts       # User seeding logic\n  │   ├── accounts.ts    # Account seeding logic\n  │   └── ...            # Other model seeding files\n  └── seed.ts            # Prisma seed script entry point\n```\n\n3. Implement the main seed script in `prisma/seed.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\nimport { seedDatabase } from './seed/index';\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  console.log('Starting database seeding...');\n  await seedDatabase(prisma);\n  console.log('Database seeding completed successfully');\n}\n\nmain()\n  .catch((e) => {\n    console.error('Error during database seeding:', e);\n    process.exit(1);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n```\n\n4. Create the seed index file in `prisma/seed/index.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\nimport { seedUsers } from './users';\n// Import other seed functions\n\nexport async function seedDatabase(prisma: PrismaClient) {\n  // Implement idempotent seeding by checking if data already exists\n  const userCount = await prisma.user.count();\n  \n  if (userCount === 0) {\n    console.log('Seeding users...');\n    await seedUsers(prisma);\n  } else {\n    console.log('Users already seeded, skipping...');\n  }\n  \n  // Add similar checks and calls for other models\n  // Make sure to seed in the correct order based on relationships\n}\n```\n\n5. Implement model-specific seed files with faker.js, for example `prisma/seed/users.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\nimport { faker } from '@faker-js/faker';\n\nexport async function seedUsers(prisma: PrismaClient) {\n  const users = [];\n  \n  // Create admin user for testing\n  users.push({\n    name: 'Admin User',\n    email: 'admin@example.com',\n    password: '$2b$10$EpRnTzVlqHNP0.fUbXUwSOyuiXe/QLSUG6xNekdHgTGmrpHEfIoxm', // 'password'\n    role: 'ADMIN',\n  });\n  \n  // Generate 10 random users\n  for (let i = 0; i < 10; i++) {\n    users.push({\n      name: faker.person.fullName(),\n      email: faker.internet.email(),\n      password: '$2b$10$EpRnTzVlqHNP0.fUbXUwSOyuiXe/QLSUG6xNekdHgTGmrpHEfIoxm', // 'password'\n      role: 'USER',\n    });\n  }\n  \n  // Use createMany for efficiency\n  await prisma.user.createMany({\n    data: users,\n    skipDuplicates: true, // Makes it idempotent\n  });\n  \n  return users;\n}\n```\n\n6. Handle relationships between models, for example in `prisma/seed/accounts.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\nimport { faker } from '@faker-js/faker';\n\nexport async function seedAccounts(prisma: PrismaClient) {\n  // Get all seeded users to create related accounts\n  const users = await prisma.user.findMany();\n  \n  for (const user of users) {\n    // Create 1-3 accounts for each user\n    const accountCount = faker.number.int({ min: 1, max: 3 });\n    \n    for (let i = 0; i < accountCount; i++) {\n      await prisma.account.create({\n        data: {\n          userId: user.id,\n          type: faker.helpers.arrayElement(['oauth', 'email', 'credentials']),\n          provider: faker.helpers.arrayElement(['google', 'github', 'credentials']),\n          providerAccountId: faker.string.uuid(),\n          // Add other required fields\n        },\n      });\n    }\n  }\n}\n```\n\n7. Add the seed script to `package.json`:\n```json\n{\n  \"scripts\": {\n    \"seed\": \"prisma db seed\",\n    \"seed:reset\": \"prisma migrate reset && prisma db seed\"\n  },\n  \"prisma\": {\n    \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"\n  }\n}\n```\n\n8. Create a documentation file for seeding in `docs/database-seeding.md`:\n```markdown\n# Database Seeding\n\nThis project includes database seeding functionality to populate the database with realistic test data.\n\n## Running Seed Scripts\n\nTo seed the database with test data:\n\n```bash\nnpm run seed\n```\n\nTo reset the database and re-seed:\n\n```bash\nnpm run seed:reset\n```\n\n## Seed Data\n\nThe seeding process creates:\n- Admin user (email: admin@example.com, password: password)\n- 10 random users with realistic data\n- Related accounts, sessions, and other model data\n- [Add details about other seeded data]\n\n## Extending Seed Scripts\n\nTo add seeding for a new model:\n1. Create a new file in `prisma/seed/` for your model\n2. Implement the seeding logic using faker.js\n3. Import and call your seed function from `prisma/seed/index.ts`\n```",
        "testStrategy": "1. Verify seed script installation and configuration:\n   - Check that all required dependencies are installed\n   - Verify the seed script is correctly configured in package.json\n   - Confirm the seed directory structure is properly set up\n\n2. Test the seeding process:\n   - Run `npm run seed` on a clean database\n   - Verify that all models are populated with the expected number of records\n   - Check that the admin user and test accounts are created correctly\n   - Verify relationships between models are correctly established\n\n3. Test idempotency:\n   - Run the seed script multiple times\n   - Verify that duplicate records are not created\n   - Confirm that existing records are not modified unexpectedly\n\n4. Test data quality:\n   - Verify that generated data is realistic and follows expected patterns\n   - Check that email addresses, names, and other fields follow proper formats\n   - Ensure that dates are within reasonable ranges\n\n5. Test relationships:\n   - Query related models to verify foreign key relationships\n   - Check that all required relationships are properly established\n   - Verify cascading operations work as expected\n\n6. Test the reset functionality:\n   - Run `npm run seed:reset`\n   - Verify that the database is completely reset before seeding\n   - Confirm all tables are populated with fresh data\n\n7. Test documentation:\n   - Follow the documentation to run the seed scripts\n   - Verify that all commands work as documented\n   - Check that the documentation accurately describes the seeded data",
        "status": "pending",
        "dependencies": [4],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Configure Deployment Documentation",
        "description": "Create comprehensive deployment documentation covering production environment setup, CI/CD pipeline configuration, environment variables, database migrations, deployment checklists, and rollback procedures.",
        "details": "1. Document Production Environment Setup:\n```markdown\n# Production Environment Setup\n\n## Infrastructure Requirements\n- Server specifications (CPU, RAM, storage)\n- Network configuration\n- Required services (Redis, PostgreSQL, etc.)\n- Domain and SSL certificate setup\n\n## Installation Steps\n- Operating system configuration\n- Node.js installation and version requirements\n- Database setup\n- Web server configuration (Nginx/Apache)\n- Security considerations\n```\n\n2. Create CI/CD Pipeline Configuration Documentation:\n```markdown\n# CI/CD Pipeline Configuration\n\n## GitHub Actions Workflow\n```yaml\nname: Deploy to Production\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run tests\n        run: npm test\n      - name: Build application\n        run: npm run build\n      - name: Deploy to production\n        # Deployment steps here\n```\n\n## Deployment Process\n- Code quality checks\n- Test execution\n- Build process\n- Deployment strategy (Blue/Green, Canary, etc.)\n- Post-deployment verification\n```\n\n3. Document Environment Variables:\n```markdown\n# Environment Variables\n\n## Required Variables\n| Variable Name | Description | Example Value | Required |\n|---------------|-------------|--------------|----------|\n| DATABASE_URL | PostgreSQL connection string | postgresql://user:pass@localhost:5432/db | Yes |\n| NEXTAUTH_SECRET | Secret for NextAuth.js | complex-random-string | Yes |\n| NEXTAUTH_URL | Base URL for NextAuth.js | https://example.com | Yes |\n| OAUTH_CLIENT_ID | OAuth provider client ID | client-id-value | Yes |\n| OAUTH_CLIENT_SECRET | OAuth provider client secret | client-secret-value | Yes |\n\n## Optional Variables\n| Variable Name | Description | Default Value | Required |\n|---------------|-------------|--------------|----------|\n| LOG_LEVEL | Application logging level | info | No |\n| CACHE_TTL | Cache time-to-live in seconds | 3600 | No |\n\n## Environment-Specific Configuration\n- Development vs. Production settings\n- Secrets management best practices\n- Using .env files vs. environment variables\n```\n\n4. Document Database Migration Process:\n```markdown\n# Database Migration Process\n\n## Pre-Deployment Steps\n1. Create a database backup:\n```bash\npg_dump -U username -d database_name > backup_$(date +%Y%m%d_%H%M%S).sql\n```\n\n2. Review migration changes:\n```bash\nnpx prisma migrate diff --from-schema-datamodel prisma/schema.prisma --to-schema-datasource DATABASE_URL\n```\n\n## Deployment Steps\n1. Run migrations in production:\n```bash\nnpx prisma migrate deploy\n```\n\n2. Verify migration success:\n```bash\nnpx prisma db pull\n```\n\n## Rollback Procedure\n1. Restore from backup:\n```bash\npsql -U username -d database_name < backup_file.sql\n```\n\n2. Revert to previous schema version (if using Prisma):\n```bash\nnpx prisma migrate resolve --rolled-back \"migration_name\"\n```\n```\n\n5. Create Deployment Checklists:\n```markdown\n# Deployment Checklist\n\n## Pre-Deployment\n- [ ] All tests passing in CI pipeline\n- [ ] Database backup created\n- [ ] Deployment plan reviewed\n- [ ] Required environment variables configured\n- [ ] Monitoring systems ready\n- [ ] Team notified of upcoming deployment\n\n## Deployment\n- [ ] Maintenance mode enabled (if applicable)\n- [ ] Database migrations applied\n- [ ] Application code deployed\n- [ ] Static assets updated\n- [ ] Cache cleared (if applicable)\n- [ ] Smoke tests executed\n\n## Post-Deployment\n- [ ] Application health checks passing\n- [ ] Error rates normal\n- [ ] Performance metrics within expected ranges\n- [ ] Sample user flows tested\n- [ ] Maintenance mode disabled (if applicable)\n- [ ] Deployment logged in change management system\n```\n\n6. Document Rollback Procedures:\n```markdown\n# Rollback Procedures\n\n## When to Rollback\n- Critical functionality broken\n- Unacceptable performance degradation\n- Security vulnerability introduced\n- Data integrity issues\n\n## Rollback Process\n1. Decision to rollback made by [role/team]\n2. Notify team of rollback decision\n3. Enable maintenance mode\n4. Restore previous application version:\n```bash\n# Example rollback command\ngit checkout v1.2.3\nnpm ci\nnpm run build\n# Redeploy previous version\n```\n5. Restore database to pre-migration state (if needed)\n6. Verify application functionality\n7. Disable maintenance mode\n8. Notify team of completed rollback\n9. Document rollback in incident report\n\n## Post-Rollback Actions\n- Root cause analysis\n- Fix issues in development\n- Improve testing to catch similar issues\n- Update deployment process if needed\n```\n\n7. Compile all documentation into a single deployment guide:\n```markdown\n# Deployment Guide\n\n## Table of Contents\n1. Production Environment Setup\n2. CI/CD Pipeline Configuration\n3. Environment Variables\n4. Database Migration Process\n5. Deployment Checklist\n6. Rollback Procedures\n\n## Introduction\nThis guide provides comprehensive instructions for deploying the application to production environments...\n```",
        "testStrategy": "1. Review Documentation Completeness:\n   - Verify all six required sections are included and comprehensive\n   - Check for clarity, accuracy, and completeness of each section\n   - Ensure all code examples and commands are correct and properly formatted\n\n2. Validate Environment Setup Documentation:\n   - Have a team member follow the environment setup instructions on a clean server\n   - Verify all required components are installed correctly\n   - Confirm the application runs properly in the configured environment\n\n3. Test CI/CD Pipeline Configuration:\n   - Implement the documented CI/CD workflow in a test environment\n   - Verify the pipeline executes all steps correctly\n   - Confirm successful deployment to a test environment\n   - Test pipeline behavior with both passing and failing tests\n\n4. Verify Environment Variables Documentation:\n   - Check that all required environment variables are documented\n   - Verify example values are appropriate and secure\n   - Test application behavior with missing variables to confirm requirements\n   - Validate that sensitive information handling follows security best practices\n\n5. Test Database Migration Process:\n   - Execute a test migration in a staging environment\n   - Verify backup and restore procedures work as documented\n   - Test rollback procedures to confirm they restore the database correctly\n   - Validate that the migration process handles data integrity correctly\n\n6. Validate Deployment Checklists:\n   - Perform a mock deployment following the checklist\n   - Verify each item on the checklist is actionable and clear\n   - Confirm the checklist covers all critical deployment steps\n   - Test the checklist with team members not involved in its creation\n\n7. Test Rollback Procedures:\n   - Simulate a failed deployment in a test environment\n   - Execute the rollback procedure as documented\n   - Verify the application returns to a working state\n   - Confirm all rollback steps are clear and executable under pressure\n\n8. Documentation Accessibility Test:\n   - Ensure documentation is accessible to all team members\n   - Verify documentation is properly formatted for both online viewing and printing\n   - Test navigation between sections and references\n   - Confirm documentation is version-controlled and updatable",
        "status": "pending",
        "dependencies": [1, 4, 10, 13, 14],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Set Up NestJS Backend for Hybrid Architecture",
        "description": "Implement a NestJS backend in the /backend directory with Prisma integration, JWT authentication, Swagger documentation, exception handling, and security middleware.",
        "details": "1. Initialize a new NestJS project in the backend directory:\n```bash\n# Install NestJS CLI globally if not already installed\nnpm install -g @nestjs/cli\n\n# Create a new NestJS project in the backend directory\nnest new backend\ncd backend\n```\n\n2. Configure Prisma with NestJS:\n```bash\n# Install Prisma dependencies\nnpm install @prisma/client\nnpm install -D prisma\n\n# Initialize Prisma\nnpx prisma init\n\n# Copy existing Prisma schema from the main project\ncp ../prisma/schema.prisma ./prisma/\n\n# Install NestJS Prisma utilities\nnpm install nestjs-prisma\n```\n\n3. Create a Prisma service module:\n```typescript\n// src/prisma/prisma.service.ts\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {\n  async onModuleInit() {\n    await this.$connect();\n  }\n\n  async onModuleDestroy() {\n    await this.$disconnect();\n  }\n}\n\n// src/prisma/prisma.module.ts\nimport { Module, Global } from '@nestjs/common';\nimport { PrismaService } from './prisma.service';\n\n@Global()\n@Module({\n  providers: [PrismaService],\n  exports: [PrismaService],\n})\nexport class PrismaModule {}\n```\n\n4. Set up authentication with JWT and Passport:\n```bash\n# Install authentication dependencies\nnpm install @nestjs/passport @nestjs/jwt passport passport-jwt passport-local\nnpm install -D @types/passport-jwt @types/passport-local\n```\n\n5. Create authentication modules:\n```typescript\n// src/auth/auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { JwtModule } from '@nestjs/jwt';\nimport { PassportModule } from '@nestjs/passport';\nimport { AuthService } from './auth.service';\nimport { AuthController } from './auth.controller';\nimport { JwtStrategy } from './strategies/jwt.strategy';\nimport { LocalStrategy } from './strategies/local.strategy';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: process.env.JWT_SECRET,\n      signOptions: { expiresIn: '1h' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  controllers: [AuthController],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n6. Implement JWT strategy:\n```typescript\n// src/auth/strategies/jwt.strategy.ts\nimport { Injectable } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: process.env.JWT_SECRET,\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, email: payload.email };\n  }\n}\n```\n\n7. Create API documentation with Swagger:\n```bash\n# Install Swagger dependencies\nnpm install @nestjs/swagger swagger-ui-express\n```\n\n8. Configure Swagger in main.ts:\n```typescript\n// src/main.ts\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  // Set up global validation pipe\n  app.useGlobalPipes(new ValidationPipe({\n    whitelist: true,\n    transform: true,\n    forbidNonWhitelisted: true,\n  }));\n  \n  // Set up Swagger documentation\n  const config = new DocumentBuilder()\n    .setTitle('API Documentation')\n    .setDescription('The API description')\n    .setVersion('1.0')\n    .addBearerAuth()\n    .build();\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);\n  \n  // Enable CORS\n  app.enableCors();\n  \n  await app.listen(3001);\n}\nbootstrap();\n```\n\n9. Implement global exception filters:\n```typescript\n// src/common/filters/http-exception.filter.ts\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from '@nestjs/common';\nimport { Request, Response } from 'express';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    const status = exception.getStatus();\n\n    response.status(status).json({\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      message: exception.message,\n    });\n  }\n}\n```\n\n10. Configure security middleware:\n```bash\n# Install security dependencies\nnpm install helmet\n```\n\n11. Add security middleware in main.ts:\n```typescript\n// src/main.ts (updated)\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\nimport { HttpExceptionFilter } from './common/filters/http-exception.filter';\nimport * as helmet from 'helmet';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  // Apply security middleware\n  app.use(helmet());\n  \n  // Set up global validation pipe\n  app.useGlobalPipes(new ValidationPipe({\n    whitelist: true,\n    transform: true,\n    forbidNonWhitelisted: true,\n  }));\n  \n  // Apply global exception filter\n  app.useGlobalFilters(new HttpExceptionFilter());\n  \n  // Set up Swagger documentation\n  const config = new DocumentBuilder()\n    .setTitle('API Documentation')\n    .setDescription('The API description')\n    .setVersion('1.0')\n    .addBearerAuth()\n    .build();\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);\n  \n  // Enable CORS\n  app.enableCors();\n  \n  await app.listen(3001);\n}\nbootstrap();\n```\n\n12. Create environment configuration:\n```bash\n# Create .env file in backend directory\ntouch .env\n\n# Add environment variables\necho \"DATABASE_URL=\\\"postgresql://username:password@localhost:5432/mydb?schema=public\\\"\" >> .env\necho \"JWT_SECRET=\\\"your-secret-key\\\"\" >> .env\necho \"PORT=3001\" >> .env\n```\n\n13. Update package.json scripts:\n```json\n\"scripts\": {\n  \"build\": \"nest build\",\n  \"format\": \"prettier --write \\\"src/**/*.ts\\\" \\\"test/**/*.ts\\\"\",\n  \"start\": \"nest start\",\n  \"start:dev\": \"nest start --watch\",\n  \"start:debug\": \"nest start --debug --watch\",\n  \"start:prod\": \"node dist/main\",\n  \"lint\": \"eslint \\\"{src,apps,libs,test}/**/*.ts\\\" --fix\",\n  \"test\": \"jest\",\n  \"test:watch\": \"jest --watch\",\n  \"test:cov\": \"jest --coverage\",\n  \"test:debug\": \"node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand\",\n  \"test:e2e\": \"jest --config ./test/jest-e2e.json\",\n  \"prisma:generate\": \"prisma generate\",\n  \"prisma:migrate\": \"prisma migrate dev\",\n  \"prisma:studio\": \"prisma studio\"\n}\n```",
        "testStrategy": "1. Verify NestJS project initialization:\n   - Confirm the NestJS project structure is correctly set up in the /backend directory\n   - Verify all required dependencies are installed\n   - Check that the project builds without errors: `npm run build`\n   - Ensure the development server starts correctly: `npm run start:dev`\n\n2. Test Prisma integration:\n   - Verify Prisma schema is correctly configured\n   - Test database connection: `npx prisma db pull`\n   - Run migrations to ensure they apply correctly: `npx prisma migrate dev`\n   - Test the PrismaService by creating a simple endpoint that queries the database\n\n3. Validate authentication implementation:\n   - Test user registration endpoint\n   - Test login endpoint and verify JWT token generation\n   - Verify protected routes require valid JWT tokens\n   - Test token expiration and refresh functionality\n   - Ensure password hashing is implemented correctly\n\n4. Test Swagger documentation:\n   - Navigate to the Swagger UI endpoint (/api/docs)\n   - Verify all API endpoints are properly documented\n   - Test the interactive documentation by executing API calls\n   - Ensure authentication is properly integrated with Swagger\n\n5. Verify exception handling:\n   - Test error responses for various scenarios (validation errors, not found, etc.)\n   - Ensure consistent error format across all endpoints\n   - Verify proper HTTP status codes are returned\n\n6. Test security features:\n   - Verify CORS is properly configured\n   - Test Helmet security headers\n   - Check for proper handling of sensitive information\n   - Verify rate limiting functionality if implemented\n\n7. Integration testing:\n   - Test communication between Next.js frontend and NestJS backend\n   - Verify that authentication works end-to-end\n   - Test data consistency between frontend and backend\n\n8. Performance testing:\n   - Measure response times for key endpoints\n   - Test the application under load to ensure stability",
        "status": "pending",
        "dependencies": [4, 8],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-28T02:08:50.599Z",
      "updated": "2025-07-28T07:49:46.354Z",
      "description": "Tasks for master context"
    }
  }
}
